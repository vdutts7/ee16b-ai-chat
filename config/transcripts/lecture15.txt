Okay, it's time for our class. Welcome to Tuesday lecture, Lecture 15. As it turns out, if you want to keep track of it, it is module two, lecture three, lecture two-and-a-half. Actually, I didn't have the full first lecture. Today. We are going to finish up system ID, which we started last time. I'll do a recap so we get back into the groove and talk about an important concept of stability. So before we just reminders, your midterm is next Monday and you should get all the logistics and stuff on posted on Ed or reach out to the TAs. If you are not sure. It'll be eight to ten, please show up on time, not Berkeley time. Be there before eight. There will be a review session tomorrow, seven to nine. Again, check ed for post details. Good news. No class. Next Tuesday. You guys are going to have be working through Monday night that would give you a break. So Tuesday no class. Okay. Any questions on logistics or other things? No. Okay. Good. So then let's do a recap. So last time we had talked about this concept of system identification. So what is the concept? What is the meaning of that? Well, you're given a difference equation for the system discrete time. X, of course is the state, D is for discrete, and U is the control, right? And this is the scalar different, difference equation. And this is the most general form. And last time we had shown that oftentimes, you know the, you don't know the model parameters lambda d and b d, right? So we need to learn them. How do we do that? And in the presence of disturbance, which is two, which is the error term that models any deviation from the model. So if we know that models are not perfect. So any errors in the models have to be sort of sucked into some term. That's the term in which you suck it into. And the goal is to learn lambda d and BD based on doing measurements from data. So how do you do that? Well, you first form a vector of all your unknowns. In our case, it's lambda d and BD is just two. And you start, basically, you look at the system, you enumerate it for vet values of k, k equal to zero, k equal to one, k equal to two. And at each k, you have to start with an initial state, which is x d of zero. And then you are going to have an input UD of zero, and that is going to produce an x d of one and then UD of one x D of 2.4. And that's exactly what we have shown here. For k equal to 12.3. And we know that high level in order to estimate lambda d and BD, we need to have enough equations to solve for them. And that's our familiar territory of least-squares, right? These are the scalar differential equations. Least squares is still review. So lambda d and b d are the unknowns. So you form a system of equations based on sweeping values of k from zero to L minus one. So you will assume you have n observations. And these are the system of equations. D times P equals S money, just write this in matrix form. And you solve for p hat, which is lambda d hat, d hat, using your least squares formula. What is the least squares? Again, very quick recap. It's basically you are, S is my right-hand side. This is the vector d p equals S. S is the vector that I know, I know S and D, I don't know p. So an S in general is gonna be a vector like shown in the yellow, in yellow here. D times p is going to be this subspace. It's all vectors of the form of d times p lie on the subspace. And for every choice of p. So this is the column space of a, D. D is something, you know, we know that we cannot approximate. We cannot solve for S equal to dp and less as also lies on that subspace. In general, it won't. So what is the best you can do? You project the orthogonal projection of S onto the subspace, which is exactly the least squares solution, or D times PLS, the error that you form is e. So of all the places you could move on the subspace, where would you move? So the error E is minimum in the Euclidean sense, you would exactly move where the blue arrow is, right? Okay, so that's just a review. When you solve for it. We've derived this last time and in fact you did it in 16. A. I don't need to go through it again, but just as a reminder, the least square solution is d transpose d inverse can be transpose S. All these quantities are known, so PLSS known. And of course, the caveat is that d transpose d has to be invertible. We will deal with the non-invertible case later in the course. Any questions? All clear? Too early? People are yearning, smiling. Yeah. Okay, Good. I will assume that. Now let's go to the vector case. I think we started this last time. The vector case is where a and b are now the unknown side. We had lambda DBD, just two scalar numbers. But now you have a system of equations. So let's graduate slowly. For the full vector case, what is the closest thing to a vector that's not a scalar to write for one of them. So let's make the state to have two dimension to that if there are two state variables. And let's stick to one control variable u. So this is the next graduation from 11221. Okay, so let's see how this works. So let's write out the equations and scalar form. So in vector form rather. So let's unpack x of I plus one. This is a vector of dimension to write two by one and by one is two. And X2, X1 and X2 of I plus one is of course, a two-by-two matrix, right? To have the right dimensions. A is two-by-two and B is two by one. And exactly write down these are the equations. So what are the unknowns? Anyone? What do we know and what do we not know? Yeah. Yeah. All the a's. We know the excess and then can you speak louder? You will also use an arc control. Use our engineers choice. But what else do we not know? The bees? Yeah. So we don't know the a's and b's, right? And that's what we need to estimate. And how are we gonna do that? By, by? First you start with a state x of zero. You're gonna be given that state. And then I'm going to produce a control input u of zero. And according to the dynamics of the system, x of one is going to emerge. X sub one has two parameters now, two dimensions. So X1, X1, X1 and X1 of two are going to come back. And then I'm going to put a new one and that'll produce X1, X2 and so on, x2 of one rather. So that's exactly the cone he has. In general. There's gonna be a is an n by n matrix. So you're going to have n squared parameters to estimate. You're also going to have B is going to be n by m. Because remember we mentioned that the control is of dimension m. In general, m is not equal to n, So we want to keep the degree of freedom. So you have n times m values for b, n squared values for a total of n times n plus m values. So in our example, n is two and MS1. Indeed, if you count all the A's and B's, there are six things that we need to find. So how do we do this? Well, one row at a time, Let's start with the first row. The first row is what? X1 of I plus one? A11 times X1 plus A12, X2 of I plus B11 you of I plus E one of I. Okay? So let's solve this. Let's I'm gonna mostly right, right now, so we can work together. Otherwise it'll just be one ratio. So, so for i equal to zero, so what did we say we will do? This is the first row, right? There's also a second row which we will deal with in a minute. So the first row, in order to get these guys, we have to keep enumerating the values of I. So let's start with i equal to zero. You have x one of one equals A11. X1 of zero plus A12. X2 are zero plus B11, u of zero plus E of zero. Now, let's just be mindless and I equals one x one of two. This A11 X1, X1 plus A12 X2, X1 plus B. So B one-one, you of one plus e of one, and on and on she goes. The last one is I equal to l minus one. So we will have, assuming we can take l minus one observations, x1 of l minus one. Excellent. A11 texts one of l minus one plus A12, X2 of l minus one plus B11, U of L minus one, plus e of l minus one. Okay? So question. How do we set up a least squares formulation? What's the least squares formulation and the native formats AX equals B. Or in this case, we have been using the notation of d p equals S, right? So where are all the unknowns in dB equals S? Which vector? In which of the three entities, D P or S, the P, right? Yeah. So you want to be on the left, P as a vector multiplying d equals something else, which you know. So how do we do that? So that's the question. How do we set up a least squares formulation? Remember, that is the form of DP or other. Dp plus E equals S. And we know that this is the guy that is unknown. Well, let's collect the equations that we just did here. We just collected a bunch of equations from doing the first row of this guy. So let's put, let's collect them in matrix form. And let's make sure that we will write the E11. These are the unknowns, are the ones that I've circled. So A11, A12, and B11 are the things that I don't know. So I want them in a form of the vector times a matrix, right? Equals a plus, plus, this is the error vector equals S. This is the least-squares form that I want for this case. So what goes into, into this, this is going to be my p. This is going to be, in fact, I'll call it P1 because it's the first row. I want this to be my D, and this is my E. And this is my S1 for the first row. So let's collect dp plus E equals s. So what goes into, into the first row? What should be the first row of the d vector, of the D matrix rather? X1 of zero, yes, x one of zero, x2 of zero, and u of zero. Already see that. The first equation, right? And what are the second one? Well, obviously it's x1, x1, x2 of one, u of one. And so on. What about this is gonna be of course, E one of zero. What is the first entry of S? That's the left-hand side. So I swapped the orders. No confusion. So this is going to be x one of one. The second one is gonna be X1, X2, and so on. The last one is X1 minus one, x2 of l minus one, U of L minus one. This is E one of L minus one dot, dot, dot, and this is x1 of l. Everybody see that? All I did was I formed a bunch of equations by enumerating the observations from I equal to one to zero to L minus 11 minus one. And I set it up in a form where the P1 plus E equals S1, ready-made for doing least squares. Now I can find what is my best estimate of p1? Well, go back to what we learned in least squares. So we know that let's do it in red. So we know that p1 hat, we call that the least squares estimate is going to be d transpose d inverse times d transpose S1. Exactly what we had set up. Again, the caveat being, if d transpose d is invertible, and we know what p1 hat is. P1 hat is A11 hat, a hat, and B hat. Any questions on that? So what have we done? Well, let's go back. We had 123456 unknowns. How many have we solved? He saw two of the A's and 1.1 on the bees. Guess how do you solve the other three? We only use one row. Write this equation here. We just used this equation and enumerated for various values of I. And that uncovered the values of A11, A12, and B11. The second row will expose the other, the others. You do it exactly the same way. So let's. Make sure we understand how to do that. So let's recall that maybe it'll be easier to, if we include, remember this is our equation and we are done with this guy. That's done. So let's use the second one. Let's estimate the second row of parameters, which is now a 21 to two and b12 in the same way. So let's write the second row of equations. So the second row, x2 one, x2 of y plus one equals A21, X1 plus A22, X2 plus B12, you of high plus E of I. And using the same way, we can write r d p equals S. We will put in a 2122 and B12 in our unknown vector. And what do we stick into the d? So this is my for I equal to zero, I will get x one of zero, x2 and y2, z2 of x. Sorry, I made a mistake. It's the same, it's the same matrix. That's all. So this is the first equation. Plus e to the zero equals x2 of one. We'll just write, will just note the very first equation that we have. I for I equal to zero. What do you have? The right hand side is A21 times x one of zero plus A22 times x2 of zero plus B12 times u of zero plus E two of zero equals x 2/1. That's great. And so you can write a whole sequence of equations. So for I equal to one, you will have x one of one, x2 of one, u of one, and so on. This is x2 of two. And we identify that this is my P2 is my second set of unknown, which I've accumulated in P2. And this is of course E2, and this is S2. But what about the first matrix there? Is it a D2 which is different from the first set? No, it's a fame. That's the point, right? So this is exactly the same d. Notice d here was these are X1 transpose of zero as x transpose of zero, x transpose of one, and so on. And Nu transpose. We'll get to the general case. But if you notice the entries of the D, what is the dimensions of D? It has L rows and three columns, right? So it's L by three. So every one of these entries exactly the same as the ones here. So what have we done? Well, it's the same thing, so let's draw the same thing. So we know, use least squares. So you know that p2 hat d transpose d inverse times d transpose has two. Again, I'm not going to keep carrying the caveat over, but we're going to assume d transpose d is invertible. And all of this, and this will uncover, and this is going to uncover a 21 hat, a two hat, and B12 hat. So question for you. What is the value? What is the minimum value of L? L is the number of rows in D or the number of observations I'm going to take for me to be able to do system ID. In other words, for me to estimate these parameters. Yeah. I can hear you for how many people agree it's for? L is for or L minus one is four. Any other guesses? Yeah. L would have to be for to have three equations. How many? Let me see. You need three equations, right? That's right. So what's the value of? We said that for what value of l will I have three equations? Three. You only need three. But of course, it's very unwise to use only three. Y. I mean, you could do it with three. You couldn't do it with less than three for sure. Because you have too many unknowns, you need at least as many equations and unknowns. What did you learn and least-squares about? Yeah. Right? And why is that? Because of the error, right? You want to make sure that you minimize the error. So you want to ask many roles, as many equations, as many observations as you can. But that's more data. So you have to collect more data. So that's also the flip side. At some point, there's diminishing returns and you said this is good enough. That's the engineering. Okay, good. So all this is in some sense review. I'm running a little slow here, so let me speed it up. So just note that we need handle greater than or equal to three observations of x1. X2 of I. I equals zero to I equals 123. When I write this notation, what I mean is remember that we are in the vectors k is for the states. So every time I have an observation, I get two things coming out, the X1 and X2 away because X has X1, X2, right? That's my observations. And I need three of these pairs. And of course, don't forget that I have my input control, which is u of Pi for I equals zero to two. And then plus, don't forget, you have the initial conditions of the state initials, let's just say initial state. So when you put all this together, you exactly get L has to be greater than or equal to three. Okay? Okay, so now if you put, if we stack our so we know what d and SR. So I have another question for you. Do we need to solve? We went through an example with two states to a state with having to get two states in your system and one control input. And we said we can solve for one set of unknowns using one Least-Squares and another set of unknowns using another least-squares. Do we really need to least squares to do this job? Because they have to. In general, it will be n, right? If you have an n by n system, can you think of a way of compacting our calculations so that we don't have to do least squares. 12345, all the cases. It's actually work wise. It may not be much more, much less rather. But in terms of expressing in compact form, that's definitely an easier way. Yeah. Yeah. So he says put P1 and P2, stack them next to each other, and stack F1 and F2 next to each other, then you exactly solving the same thing, right? Question. No. Okay, Good. Yeah, exactly. So question. Do we need to solve separate least-squares equations for each row? So you notice here that p1 hat is equal to d transpose d inverse times d transpose S1. That's equation one, p2 hat. Because equal to d transpose d inverse times d transpose S2 is equation two. And S was aptly suggested. Let's just tacked together p1 hat and p2 hat and write them as a matrix, P1 hat in the first column, p2 hat and the second column, which is going to be d transpose, d inverse times d transpose. And we just have to stack together S1 and S2, the second column, right? So this is the general way of doing things. We call this a matrix P, and we call this a matrix S. And it exactly follows the rules of matrix multiplication and an addition. In other words, if you put everything together, you have that p hat. P hat is now a matrix. What are the columns of P hat? P1 hat is A11, A12 hat, B11 hat. This guy is 21, sorry, A21, A22 hat, B12 hat is equal to d transpose d inverse times d transpose times S. That's it. You're done. So that if a general solution for doing system ID, yes, you will have as many dimensions as we go to the, the general setting right now. But I'm not going to go over it again. I'm just going to flash the results while you will find out. Yeah, you're right. So let's kind of well, let me first pause and see if there are any questions or yeah. Yeah. Yes. Yeah. Exactly. Yeah. Yeah. You're jumping the gun, but that's exactly right. So let's go to the general case now. Okay? So I'm just going to I'm just going to go this fast since we've already done this case. The, the illustrative case of n equal to two, m equal to one. This is the general case for any n and m. And it exactly follows the recipe we just did. Just want to make sure you understand how it works. This is how system IDs are important point because this has actually done in practice. We actually need to estimate these parameters before we can control the system, you have to first learn the parameters, you know what the system is, then we can worry about controlling it and so on, which is the rest of the course. So this is the example we just did. We just did all the stuff. Um, yeah, he has a general vector case. So you have n squared unknowns. B is n by m, right? That's a setup. The goal is to identify, just as we did earlier, a and B, we form our least-squares set of equations, d p equals s, exactly like we did a minute ago. P contains all the unknowns. And we know that p-hat equals d transpose d inverse d transpose S. Now, this is the general form. Again, we need to form a set of equations. So first thing is I'm going to drop this annoying E1, E of i term, which keeps following along like an unwanted tail jacket. Because we just made it will make us the equations to be approximately true within the error. So we know what that means. Means there's always an e term that's out there. So these are my equations, right? So x1 of I plus one is A1 transpose x i plus b1 transpose. You can see from the X1 over I plus one is the inner product of A1 with x plus b1. You forget the E term, that's exactly A1 inner product with x, which is, which I've written here. Now, I know for least squares, I want the unknowns on the right, right? Because dp equals S, P is the second term, not the first. Unfortunately here the unknowns are on the left. What should I do? I do transpose. Transpose is a trick to go, move left to right and right to left. So that's exactly what I do here. So I do A1 transpose X1, which is A1 inner product with X1 is the same thing. But because the inner product, you can commute, I can change the order of the commute of the inner product to a new and B. Same thing. And so now I have a on the right, Exactly like I like for my least squares. So this is one equation for I equal to zero. And you can see that you can get multiple observations by spanning ice, sweeping eye until you have enough, until either you get tired or you have enough to solve your problem, right? And how many equations do we have? N squared plus m n, right? So that's exactly what we need. So one equation for I equal to zero, so I'm just stacking the equations here. This is y equal to zero or equal to one, I equal to l minus one. The first column of a is exactly the unknown in the A1 and B1. There are n and m B1 for a total of N plus M unknowns in this column, right? And that's when I used only the first row. Exactly analogy to what we just did earlier with the example. So we have Dp1 equals s1, which you can now, now we can move on to the second column. So you look at x two of i plus one, and so on and so forth. Right now, A2 and B2 need to be estimated. And that's exactly what we do here using the second set of using the second row, but sweeping I from zero to L minus one, you get this set of equations. And that gets DP two equals S2. And you can imagine, as was correctly pointed out, you need to have n of them. For an n by n system, you have NPI, p1, p2, p3, pn, and SIs s1 through S N. And we just tack them. But instead of solving and least-squares, we can do it in one swoop by just plunking all the pieces together into a matrix, P1 through PN, which is equal to s1 through SN. But that's exactly, this is exactly d p1 equals p2 equals S2, right? From your matrix multiplication, you know that's the case. P-hat is equal to d transpose d inverse times d transpose S. I should actually put hats on all of these because this is an estimate. So in general, our convention is going to be our hats are going to say that it's our humility for not knowing the actual value. So humbled you've ever had. That means we don't know exactly, but because our estimate. Okay, so that's how many observations do we need? If you look at it? Greater than or equal to? In the case where n equal to two and m equal to one, we need an L greater than or equal to three minimally. But ideally want more in the case of n by n for a and n by m for b. Since we have n, we need n plus m equations now, right? In order to get this done, because you have the notice that you have n plus m unknowns here. To have n plus, to solve for N plus M unknowns. For every column, you better accumulate n plus n plus m equations minimally, right? So you need at least n plus m, n plus m equations to solve for my system. But in general, you want it a lot larger so that you can get rid of the noise, the error, the misestimation of the missed modeling. Okay, So that hence the topic of system ID. Any questions? Yeah. Can you talk a little louder? Hello? Yeah, that's a good question. You're asking when you do system ID, do we do constant control? When we are doing system ID, our goal is to learn the model, the parameters, we don't even know them, but we know the form of the equation. So the controls are things that you are just going to try. You're going to try a U of zero. And that's going to induce some x. You're going to try a U of one, and that's going to induce an x of two. We're not ready for control yet because we don't even have the model. So that's a very good point. So maybe we should even write it down. So note. When doing system ID, we are learning the model parameters by trying various input controls you of I and observing the system state from the dynamics. So first we do learn. Let's first we do system ID. Now I know my sister, so e.g. I. Know that x of I plus one equals a X plus B U of I. Let's leave it at that. Now. I have learned, used to learn star to do control. Now we are ready to do control. Every time step. Yes, you're trying various values of the voltage and then observing how the state evolves. And it can be anything you like. Once you have enough and you have estimated things, now you're ready to do your real job. Okay? That's a good question. Okay, now, let's move back to the next topic. Which is an important one, which is the topic of stability. Okay? We're going to delve in discrete time, but the concept of stability is something which is more universal, but that's discrete time and continuous time. It doesn't matter. But let's, so I'm gonna, I'm gonna add with your indulgence, I'm going to make too lazy notational things. One is that I'm going to get rid of the square brackets, which are hard to draw, right? Everything is gonna be round brackets because it's easier to write it. Second is I've been using I and L, N and K for doing the indexes in discrete-time as an index. And we ever been reserving T for continuous time. But I'm going to kind of mess it up. Not messing with you guys, not trust testing to see whether I can fully or not, but it's really just a convenience. Okay. But if you have any confusion, let me know. I hopefully you don't. So my discrete time equation, what I'm saying is that I'm gonna be able to write. So that is my discrete time equation. T is now an integer index, okay? Just like high-end k where lambda and I guess you can even use B, but I forgot. I've gotten rid of the b because I'm going to suck everything into u of t, be u of t. You're used to seeing B u of t, But we, we will just use u. So we know that this is the input, which is the engineer's choice. This is the noise, which is nature's choice. And we know, now we assume we have already done system ID. We know our Lambda, we have already identified it. So we're going to deal with the scalar case first. So this is known. We'll assume that lambda is known. Okay? Now, let's get rid of the u of t and w of t for the moment. Let's forget this and forget this. And let's do an example. Suppose I told you x of t plus one is minus two times x of t. Intuitively, do you think the system is stable without telling you anything about stability? What a stable mean? I think Professor nicknames that also covered the concept of stability. So it shouldn't be totally foreign to you. What does stability mean? What do you think it means? Yeah. It needs to stay bounded. That's what you're looking at, right? If my system blows up as time goes to infinity, that is not a very good situation. That is an unstable system. So what happens to the system? I've ignored the e of t and w of t terms. Actually I should use EFT. Let me, let me go back and we've been using E of t, So I've plunked WFD. So what happens to the system when t gets larger and larger? Yeah. Yeah, it gets the magnitude is going to get, it's gonna go up and down, right? Because it's plus, because minus two, every value is multiplying the previous one by either two or minus two before he annoyed you're an infinity. So this is not a good society. Let's try to do that. So x of zero is zero. X of zero is x of zero. That's not saying anything to dusk statement. X of one is minus two, x of zero. X of two is minus two squared times x of zero, and so on. So x of t plus one is going to be. So you can see that x off, which goes as t goes to infinity, to either plus or minus infinity. So of course, there's one caveat for this. How come nobody pointed out? Usually somebody is sharp enough to say, we won't always go to infinity. When will it not go to infinity? If you start at zero or stuck at zero, right? But that doesn't escape the definition of stability. Because as we will see, in order to be stable, you need to deal with any initial condition no matter what, as long as it is a bounded initial condition, zero is a lucky choice. Okay? You got lucky and thought you said, Oh, I'm stable. Well, if I just change zero to 0.01, you're dead, right? So that's not announced. So when you have noise and perturbations, you need stability is a notion of robustness. Okay? So the second example, x of t. Because t, x of t, x of t plus one t. That's a bad statement. I meant. What happened here? Yeah. Yeah. You see what happens as t goes to infinity, any fraction to the power, large power goes to zero. So x of t plus one is going to go to zero, which is a good thing. It's not blowing up. So we say that this is stable. That's an intuitive feeling of stable, whereas this guy is unstable. Right? Okay, So let's kinda define what we mean by stability. First, there's the notion of state stability. It says that a system is stable. So I'm going to start using some math notations because I'm lazy. And you guys should get up with the stuff. If you don't know these notations, people know what this means. I didn't make a typo. Who knows what this means? If and only if. So, whenever you see if it's if and only if, Who knows what that means. There exists if and only if there exists a k, a bounded k, such that the magnitude of x of t is less than K for all time t. Okay? Which I can also say for any t. So again, just as a notational thing, this means I'll say it once and never again. This is if and only if. So that is the state stability definition, which says that k is some finite number, okay? Some bound. And you are required in order to be States table for the x of t. No matter which t I take, including t going to infinity to stay within. It cannot be outside. So you need, you need to be between minus k and k. If you are, you're staying within bombs. You can't go out of bounds. So this is called, let me use. So let's proceed. Now, remember that I had ignored the input. I said, let's forget about the input and let's just look at the state evolution. By the way, the evolution of states when states go 1-2 to three to infinity is also called a state trajectory. When you hear the word trajectory, it's the, it's the sequence of states. Have they evolved by the dynamical system? So, let's start with initial conditions of x of zero equal to one. And let's have the equation. X of t plus one is minus two x of t plus u of t. Well, we saw that even when u of t was zero for all time, this was unstable in the sense that x of t was not going to be within bones. There's no finite k that x of t would lie under. So this is unstable no matter what, right? So notice this is, Let's do the second example. X of t plus one equals one-half, x of t plus u of t. Well, now we have u of t, cat maybe blow your x of t plus one up. Even if x of t is well behaved, maybe you is going to misbehave. And in order to deal with that, we have a notion of we need to keep the input also bounded. And that leads to an important notion which is called the new definition. So the first definition is just for the states without regard to the inputs. But now we have a new definition which is called this is also called BIBO stability. What does it mean? Exactly what it says in words. You give me any bounded input. What do I mean by a bounded input? That means if I draw barriers around the input which are finite, obviously, the input will not exceed those barriers. It will stay within the bounds of these barriers. That's a bounded input. When I have a bounded input and I have any initial condition, not just zero, could be non-zero, but as to be finite. Then the output also stay within bounds. For as long as the output stays within bounds. When the input stays within bounds, you are called BIBO stable. If that's not the case. Bibo unstable. That clear. Okay, Let's do some examples, but let's first define this. So it says BIBO stable. Says that if every, this is the English definition. Every bounded input, you for, for every bounded input u and initial state X of zero. The resulting state trajectory. Exactly what I said earlier. X, he has bounded. So that's the sort of English meaning. Now let's do the math. You meaning, which is just throwing some epsilons and there exists things. So when BIBO stable, if and only if for E greater than zero, u of t less than or equal to E, That means the input is bounded. I should also say for all t, then there exists a k strictly bounded less than infinity such that that's the other SD is such that x of t also bounded to within K for all t. Okay? So this is the definition of BIBO stable. Okay, let's learn this through examples. That's it. That's the easiest way to check whether a system is stable or not. Okay, so let's look at the system. X of t plus one equals lambda x of t plus u of t. And we know that we know that u of t is going to be less than or equal to e. E is some finite number, positive number. And we'll assume here that lambda is greater than one, e.g. two or minus two or 1.5 or something, right? What is your guess? Stable or not stable? Say thumbs up. If it's stable, thumbs down, if it's unstable. Comes down, yes. You're right. Your guess? Is that not BIBO stable? But we need to prove it because it has to go through the rigors of the mathematical proof of stability. So let's do that. Proof. What do we need to do to prove this? You need to find an input u of t, for which the system blows up. You feel that the system is going to blow up. Can you tell me an input which is bounded, which is going to cause the system to blow up. So what would be such a system? Yeah. Yeah, Actually, no, no, no. Input will also do it in this case, right? But the initial conditions have to be at x of zero not equal to zero. There's also, by the way, this also has to be true for every initial. I should also add the caveat that this must be true for. Okay, That goes without saying. So the proof is to find some u of t such that the system blows up. So instead of zero for all time. So let, let's, let's try the following. We will say that u of zero is equal to e. I remember I'm allowed to be with an E. That's a u of zero is e and u of t is zero for all t greater than zero. So I just want to have my first control input is going to be E, and then it's gonna be all zeros. What do you get? Well, you get X of zero is zero. X sub one has lambda x of zero plus u of zero, which is lambda x of zero plus e. X of two is going to be Lambda times Lambda x zero plus e plus zero, because the input after that is zero, and so on. So you'll get that x of t is going to be lambda to the T minus one times lambda x zero plus e. So what is the magnitude of x of t? Magnitude of a product is the product of the magnitudes. And the second term doesn't even matter. I know it's bounded. But we know that this guy goes to infinity. Since, since lambda is greater than one. So this is BIBO unstable. Okay, let's add another page. So now let's do another example, which is x of t plus one equals lambda x of t plus u of t, just as before. And we know that u of t is bounded to less than e. And now I'm going to say that lambda and magnitude is less than one. In general, lambda can be complex also. But we'll deal with the real case first. But we'll first assume that the magnitude of lambda, of the absolute value of lambda, if it is real, less than one. What is your guess? Yay or nay. All the ones that thumbs up? Yeah. I see a few thumbs up. Some are sleeping, that's fine. I guess. The reason I want to bring this example up is that the proof is no longer saying that, Hey, here's a u of t for which its table. Because that doesn't meet our stringent conditions for stability, right? Because you gave me one u of t. I'm going to ask, what about this u of t? You didn't analyze that. So what do you have to show? To show that a system is BIBO stable for all u of t. So man, the math gets hairy then. It gets a little heavier because you have to accommodate every single you in the world that you could, all the controls signals that you could have asserted, which stay within magnitude e are fair game. And you have to prove that no matter which signal I put in, I'm still going to be bounded in my state sequence. So it's a little harder. So you see that That's a little subtler. Whereas the source show something is unstable. To show a counterexample, you have to show only one u of t that blows up your system. If it doesn't blow up the system for some u of t, it doesn't mean it's unstable. But if it blows up for any u of t, it is unstable. But every single u of t has to make it stable. They fight. For every UFD. If your output is bounded, then you are BIBO stable. The clear, it's a very important concept. Yeah. And all initial conditions also. Yes. Yeah, exactly. In general, but we will see that those are not that important. But you're right. All and in particular, if you want to really get carried away and all finite disturbances, which is the noise term. But those are the add-ons. You can easily show that the important thing is the input. But you're right, You're absolutely right. Okay, so let's prove it. I have about 10 min, okay, that should be enough. I want to write the fact. You have to show it's true for all U of T's. Okay? So x sub one lambda x of zero plus u of zero. My first equation, x of two, lambda x of one plus u of one. This is going to be lambda times, Let's plugin from the first equation. Lambda X, Lambda X of zero plus u of zero plus u of one. So when the smoke clears, this is Lambda squared X of zero plus lambda u of zero plus u of one. That's x of t. I'm just writing the recursion one-by-one. And you have seen recursions of this form ad nauseum in this course, right? So many times you have seen these equations. So it should be second nature to you by now. So let's try one more. X of three equals lambda cube hexose zero plus lambda squared, u of zero plus lambda u of one plus U of two. So I don't know which describes that there were there was a full discussion section dedicated to this. And you have notes that are dedicated to this. I don't remember the numbers of those dates are the numbers of these things. But basically, you know that x of t, In fact we even did it last class. Lambda to the t x zero plus summation lambda to the i u of t minus one minus I. I equals zero to t minus one. So everybody comfortable with this? This is stuff that you should already have seen before. I'm just repeating it. The argument is the same. So this is the, now. Let's add another page. So we want x of t to be less than K for all t. That's our goal. We want to show. When u of t is less than E for all t, x of t is less than k for all k. So let's take absolute values. So let's box this equation first. So good. So take absolute value of both sides of star. Star is this equation. What do you get? You get the magnitude or the absolute value of x of t is equal to the absolute value of lambda to the t x of zero plus the summation term I equals zero to t minus one lambda to the i u of t minus one minus i absolute value. What do you know about the sum of absolute values compared to the absolute value of the sum? Yeah. Yeah, which one is less? A plus b? Absolute value is less than or equal to absolute value of a plus absolute value of B. That is called the triangle inequality for just a fancy name for saying the absolute value of a plus b is less than or equal to absolute value of a plus absolute value of b. Okay? So let's use and we're going to use it repeatedly. So also known as that's aka right triangle inequality. Two sides of a triangle r cannot be larger than or larger than the third side, right? That's exactly the same, same phenomenon, right? So if you can write these are all vectors. The magnitude of a plus b is the length of the third side, which is less than or equal to the sum of the two sides of the triangle. Same thing. That's why it follows from that. But however you do it, this is just for your information. So you can see here that x of t absolute value is less than or equal to lambda to the t x zero plus the absolute value of lambda to the high u of t minus one minus I. I equals zero to t minus one. Okay? Just invoked triangle inequality once. Now, what about the first term? We know that lambda is less than half, less than one, right? That was the premise. So what happens to them? An extra zero at some bounded number. What is the magnitude of lambda t, lambda to the t x of zero for any t from t equals zero to infinity. What can you say definitively about it when lambda is less than one in magnitude, yeah. It's always less than x of zero. Think of if you're, if you're having trouble picturing this, imagine lambda is a half. You started at a half and then goes to a quarter. One-eighth will always be less than zero, which we know is bounded. That's the petrol. You want to do that. What about the second term? Well, again, it's absolute value of a sum. Let's use the triangle inequality repeatedly. You can use it for every term. So this is going to be less than or equal to. Okay, let's try. The whole thing. Is less than equal to x zero plus lambda to the i, u of t minus one minus I. I just said, you saw I equals zero to t minus one. What did I do? I had the absolute value of a bunch of terms is less than or equal to the sum of the absolute value of those terms. And we know that the product of absolute values as the absolute value of a product is the product of the absolute value. That's a, that's an obvious statement. So that's how everybody see this. This is by repeated. I'm taking lots of shortcuts. I'm saying by repeated application of the triangle inequality, That's what I'm writing down. Okay? So what happens is that this is gonna be less than or equal to x of zero plus. Now what do I know? Has a starting point about u of t minus one minus I. What was my hypothesis? Yeah, always less than or equal to E. That was our starting point. We said that when the input is bounded only then I need to show the output is bounded. Well, when u of t minus one minus I for any t absolute sum, absolute value is less than E. So therefore, I'll be done in a minute, just a second. So I can pull the E out of the summation and I will have height equals zero to t minus one half lambda to the absolute value. What is this? Where have you seen that sum before? And what does that sum called? Geometric series, right? Right. Yeah, good. All geometric series. So this is nothing more than, remember that this is Lambda to the I. I equals zero to t minus one is equal to one plus lambda plus lambda squared plethora dot, which you know, it's a geometric series, geometric sum. And what do you know? It's less than or equal to 1/1 minus Lambda. If Lambda is less than one. Geometric series always converges when you take an infinite number of terms to 1/1 minus lambda. So we are done. 