Okay. I guess it's time to get started. Welcome to Thursday. So let's continue from last time. So last time we started the introduction to controls, gave a motivation. And then we mentioned that we want to control physical systems which are represented as differential equations. But since you're doing it with a computer, we need to discretize things so the computer can understand what's going on. So continue. Computers don't know continuous time. So you have to discretize things. So today we're going to go more into how to do this discretization and show what the mapping is between the continuous time and discrete time that enables these digital controllers to do their processing. And then we will get into something known as system identification. System ID. Okay. So that's the plan. Any questions before we start? No. Okay. So what's the big picture? Recap. So you start with a continuous time differential equation. This is a vector differential equation in general, that's why these arrows are vectors. So this is the system that we want to solve. So in general, X sub C. So again, a reminder that the subscript c is for continuous and the subscript d is for discrete data. So we can distinguish the two. Continuous time equation has given, the differential equation is given by this, which is a dynamical system where x sub c or x is known as the state of the system. And it can have any dimension. But think scaler if you wanted to, easy and we'll do examples with scalar. And it's characterized by this equation where u sub c are you If the control input in your RLC circuit example, u is the, what somebody said last time. What is u in the RLC circuit? Independent sources, independent voltage or current sources. And x would be the voltages across the capacitors are the inductor currents. Whatever you have in your system. You compile them together in a vector form and that just stayed vector. So now we want to know. So there is a solution to this, which we have solved, which we will recap again. But since we are in the control world, the control is all about designing the right use of C. So you want to put, this is under the engineer's control. The engineer can control what u-sub see I can shove into the system and in order to expect a certain desired state response. So you may, depending on your application, e.g. you may want the robot, robot car to go from point a to point B. At time t is the time at a and at time t1 you wanted to go to B. So you want to do the control in such a way as to make that happen. Okay, and we'll study about what is controllability and so on in future lectures, but that's the big picture. So again, as a reminder, since we want to go into the discrete world, we have to stick a D to a block at the input to the continuous time so that I can start, I can have discrete inputs coming into the input of the D to a, That's the UD of 012. And the output of the D to J will be UC of t. That's the control input that we are feeding into the system. The output is going to be X sub C, which is essentially the solution to this continuous time differential equation when the input is used c of t. And this is the dynamics. Of course, since our computers don't know X sub C, we have to stick an a to D box at the output, and this will become x sub b of 0123. And so my computer, the processor, it's going to take in these discrete samples of XD and spit out these discrete samples of UD control. And we saw that last time, we delayed too deep part is just one way. If this is XC of T, D, just take snapshots. Polaroid snapshot, click, click, click, click. These are the samples. And what about the a to D? D to a part? These samples have to be interpolated. And we will, in this course, we will study zero order hold or piecewise constant interpolation of the samples to produce a continuous waveform. Because they are the simplest things you can think of. And B, because they work. You can make them work. In general, you can do other interpolation techniques. Can somebody tell me the next level, more sophisticated interpolation techniques between these points. Other than sample and hold me, basically sample it and you hold it till the next clock, which is what is shown here, right? The staircase or piecewise constant thing. Can somebody tell me what would be the next? Yeah. Yeah. Basically you can draw a straight line between these points, right? That that's called a first-order hold, okay? And you can imagine there's a second-order holds and so on. But in general, this comes under the category of so-called sampling theory, which you guys will study in one-twenty if you take it. So more sophisticated things, but we don't need it for this course because a, because as I mentioned, we'll see how to make it work. Okay? Alright, so any questions on the big picture, what we're after? Okay? How good? This has. Just a reminder that x, that x is the state vector of state variables such as VC, IL, and RLC circuits. And depending on your application and motion systems, they could be position velocity, acceleration. In engine models, they could be Flows and pressures and so on. So it depends on your system. This is a very general system. Use the control input and independent voltages and current sources, forces and torques and so on. Okay, so what you can do to change the state of the system. So we mentioned last time that x d of I plus one should be the solution. X d of I plus one is the okay. Yeah, I forgot to tell you that. I wrote it down but we didn't talk about it. This is a continuous time differential equation. The computer is going to not understand that. Instead, it's going to understand this discrete time difference equation or recursion equation, which essentially has x D of i e to the I plus one sample at x, it's AD times the height sample of X plus BD times the height sample of beauty. Sample, meaning the whole vector of samples, if it's a vector. So how do I convert this to? This is what we are going to study now. But you recognize that if the computer had this, it can very easily do the control if it knows how to spit this out, right? For e.g. at the beginning you'll have x d of zero. That's the initial state of the system. And then the controller is going to output a UD of zero. So given x d of zero and UD of zero, you can compute x D of one. The state will evolve to x d of one. Then given x d of one and x d of zero and UD zero, the controller is going to print out UD of one. And the loop continues that clear. So it's an important point. So everything is in a loop and the controller is causal. So it looks at all the stuff that's happened so far and then spits out the next control sample. And what we would like is that the discrete actions of the controller should be mimicking the continuous actions of the physical system. In other words, I would like the x B of I to represent x sub c. So let's write this down. So we want and that's what we will study today. How, how would make that happen? Okay, So that's exactly we are saying here an x D of i plus one should be the solution to the differential equation, the continuous time. Now, if I were to solve this differential equation for a staircase, you c of t, which is what our input is. And I sample, sampling at time t equal to I plus one times delta. Then that's exactly the x D of I plus one sample point. That should be the same. So x D and x have to be connected. You can't have XD running something and doing something else, right? The whole point is to connect the two, and that's the connection. And the initial conditions are because u sub c is going to be piecewise constant. We're going to zoom in on the constant intervals between delta and I plus one delta, right? From zero to delta, it's flat. From delta to delta is flat. From two delta three delta is flat, right? So if you focus on one interval from high delta t I plus one Delta, we know that u sub c is going to be flat. And what do I want X sub C of high Delta to be? The initial conditions are going to be starting at the left end of the interval, which is high delta, which we want to be x D of I. Because that's what, you know, because we have to match them right? Sample for sample. And at time t equals I plus one. And input. Yes. You d of I, which is the, which is the input for the interval from i delta two I plus one. We'll go through that more in a bit. Okay, So let's study the scalar case. We should always study the simplest example that makes the point in general. So if you can get the concept from the simplest example, then it's easy to generalize. That's how we take. So don't worry about vector cases until you understand the scalar case. So what is the scalar case? So you have dxi of t, d t. So we're going to replace, since it's just a scalar parameter. So this is my differential equation. Note that lambda and b are my AC and BC, right? Because it's just a scalar, one number, which we know because this is the physics of the system is going to dictate to tell you what lambda and BR we'll later talk about when you don't know them. Okay, So this is the continuous time system, and we will mark that as equation one. This is continuous time. In discrete time, we said that we want x D of i plus one to be equal to, we'll call it Lambda D, since it's just a scalar parameter times x d of I plus B sub d times UD of equation two. So we want to find what's our problem. Let's use this guy. So we want to find lambda d and b d as a function. So that's our mission. So goal is to find lambda d and b d of the discrete time system as functions half lambda comma b of the continuous time system. And of course, our sampling period delta, right? We know that we're sampling every Delta seconds. So that's the relationship that we're after. So how do we do it? So that's exactly the question. So we know that we want x d of I to be equal to x C of x z of t, z of delta. In equation one. Where UD, sorry, You see you continuous time control signal is going to be because of my piecewise constant assumption. You c of t is gonna be UDF. For what time? Let me see if you guys are awake. Zero UD of I right now, I can be anything. I can be 13 or A25. For what times we'll use p of t be the same as I Deltas the left end, what are the right end of the interval? I mean, I plus one Delta, Exactly. Yeah, you got it. So I delta less than or equal to t less than I plus one Delta. I'm just being technical here in that it's a closed interval on the left and open on the right, but that's nitpicking, but you understand. Okay, so that's UC of t. So what is the solution to one? You have encountered this. Have you not sold differential equations of type equation one? What's the solution? That we can say? You're going to say for t between high delta I plus one Delta will just specialize that it's always true, but you have x of t. Since your initial state, you're going to start the initial state at t naught. And this is your zero input response. And zero. So when you start at t0, this is the initial conditions. And then you go from t zero to t e to the lambda t minus Tau d Tau times b. You see of top. I hope people know how to do this. You've seen this many times. Give me a nod if you have seen it. Yeah. This is your integrating factor method or whatever, right? You guys have studied in previous lectures. Okay, good. So that's the solution. So let's box that. Now. What do we know about BUC of tau? So we have to solve this equation, and let's do this. So what is UCF? Tougher question. What is UC of tau? For tau equal to i delta? Here, the, here the picture. This is time. This is delta and this is I plus one Delta. We know that in this interval. What is the value of UC of tau for, actually, I should say, for this interval, has changed colors. For delta less than, equal to t, less than I plus one Delta. For, in this integral. Remember we're integrating with respect to tau. But we have this UC of tau. What is UC of tau for that interval? In terms of UD? What's the value of UC of high delta? We saw it earlier, right? We know that x p of i delta as what is x D of i, i, i goes on the integer axis. I takes on 1234. Time takes on the row delta two, delta three delta, right? So at time t equal to i delta, what is, what would be like XD to be hexene to be rather? Number one, what's our goal at time t equals Pi delta? We want xy delta to be what? Xd have I exactly. It has to be x D of I. So the answer is UC of tau equals UD. Sorry. You see of ij delta equals u d of I. I'm still faithfully doing round brackets, square brackets for continuous and discrete. I'll get sloppy very soon because I get tired. But for now, since you are in the beginning, I'm trying to follow the discipline. Okay? So let's solve this differential equation where t is equal to Delta, the left end of this interval. And what do we want? We want to convert. So this is z of t. We want to convert continuous time to discrete time, right? We want an equation that mirrors the differential equation, but which the computer can understand. So I'm forcing T naught. So, I'm sorry, I'm forcing this interval delta t I plus one Delta. And I'm going to make sure that in that interval I understand what's going on. Because once I know what's going on between delta and I plus one Delta, I can repeat the same thing for I plus one delta two y plus two delta and so on. The same thing, just translate it all. So what is the t I would like to pick? Because I know I want an equation of the form of equation two. So what should I pick to make the boxed equation on the left-hand side look like x d of I plus one. Yeah. Yeah, exactly. I plus one delta t should be I plus one times delta y. Because when I saw, Let's box this because these are the initial conditions. So when we do that, so you, so you will get that you use C of t equal to u d of high throughout this time interval. That is why we picked a zero order hold to make our life easy. Why? Because now I can take this UC of tau and pull it outside the integral because it's flat for the entire duration of the integral and make life easy. You see that this is where the zero order hold assumption is key. Because if it was some complicated function, I don't know what to do. Yeah. Question. Exactly. Exactly. We are, but we're leveraging that by design. We have designed, we have control over what we put in. I choose to put in a zero order hold so that I can integrate. Easy. Okay? So that's the trick. Okay, so let's write the equation. Therefore, xy X sub C of i plus one delta, which is the solution to this guy at t equal to I plus one is equal to e to the Lambda. What is t minus t naught? T I plus one Delta T naught as I delta t minus t naught is just delta i delta delta. Times x C of i delta. So I'm just plugging in these values shown here. In this equation. Okay? Yeah. No, I'm, I'm substituting x c of t naught. T naught is delta right? On the left side. T is i plus one delta. My bad. Thank you. You guys. You're absolutely right. It's I plus one delta e to the delta x, Delta plus the integral from higher delta to i plus one delta of. Well, actually let's do some simplification since we know things are constants. So one thing that we can pull out, the e to the lambda t out, Let's write it here. And then the B and UC of tau we can pull out because you know, it's, BUT I write times the integral from hi delta two I plus one delta of E to the minus lambda tau d tau. That's simple to integrate. Everybody see that? All I did was pull out all the constants stuff outside the integral. Okay? You can solve this. So in the interests of time, I'm not gonna go through the details of the integration. You guys can do that at your leisure. But you can show that this guy will evaluate to actually this whole thing, including the e to the lambda t, will evaluate to one minus e to the minus lambda delta over lambda. Okay? If you do that integral, It's a very straightforward integral. I'm not going to spend time on it because it's just doing calculus. We should do our spend our time more usefully. So anybody, everybody okay with this? Okay, you can, you should, you should convince yourself, that's the answer to that. And so when you put things together, what we know that this guy is just x D of i plus one. That's our goal. This guy is x D of I. So putting everything together, you'll see that X sub d of I plus one is e to the Lambda Delta X sub d of i plus b times one minus e to the minus lambda, delta over Lambda times UDF I. Already with me. Okay, so that's our equation. Are we done? Well, there's one slight caveat. When we did this integral. We are dividing by lambda. That gives you pause for concern. When will that be troublesome? Yeah. Yeah, exactly. When lambda zero. Lambda zero, that's a nonsense thing, right? So what do you do in lambda zero? Well, you can go back to this integral and plugging lambda equals zero, this integral just evaluate to delta. To be very clear. So this equation that we wrote is actually only partially right. Let's get rid of these things. So this is going to be, this is going to be equal to one minus e to the minus one minus e to the Lambda Delta over lambda. For lambda not equal to zero. And Delta when Lambda is zero. Okay? So with that caveat, what are we after? Remember what we were after was to find x D of i plus one and x D of high and so on. Okay, let's go to the scalar setting. We wanted to find lambda d and BD has functions of lambda B and Delta. Do pattern matching. Which one is lambda dy? That guy is lambda d. Which guy is B sub d? This guy, that's B sub d. And we have, we have them as functions of lambda b and delta mission accomplished. And for the lambda equal to zero cases, it's a simple case. This whole thing will become just be delta. It's clear, it's an important result because it's our first way of connecting continuous time to discrete time for control. Yeah. Because I chose it to be my design. That's why I chose it. If I chose something crazy, then I'd be in trouble. Okay? And it's beyond the scope of what we can do in this course. But that's a good question. Use either an out-of-control, remember. Yeah. Any other questions? Okay, good. So just as a reminder, I'll give you a simple example. So here's an example of discretization. This a very simple setting. So this is my differential equation, dx d t equals three x plus five UCSD, some system you want to control. In our setting, of course, remember, AAC or lambda is three and b, C or B is five. This is the control we apply as we analyzed. And the discrete-time difference equation on the recursion equation that the computer understands is going to be given by just plugging from the derivation we did last, on the last page. You know that this is e to the i, sorry, e to the three delta u, which is e to the lambda delta. And this is, the expression is Lambda is not one. Lambda is three, so you have e to the three delta minus one. So how will the computer proceed? It knows, remember, we come under the assumption, we enter the fray under the assumption that we know lambda and b. These are fixed, these are given by my physical system. And we also choose the delta, the sampling interval. So based on that, I can recurse in a way that a computer can easily do. Because there you will start with an x d of zero, and then you will put in a UD zero according to whatever your control policy is, and that will induce an x D of one. The next one, you prefer to use AUC of UD of one and they'll produce an x D of two and blah, blah, blah, keeps going. And you can also let there's a recursion for the discrete time equation. I wonder, maybe I will show that to you. Okay, Maybe let's, let's do that for a little bit. Just so that you understand the recursion involved. So we know that x d of I will just do it for the scalar case. And for the vector case is exactly the same except you have to make a sub d instead of lambda d and thick arrows and everywhere. Okay, it's just an annoyance. Conceptually, it's the same thing. So we'll just stick to the scalar case. Lambda d x d of x d of I plus one lambda dx dy of high plus b u d of I, right? And this is true for I equals 012 and so on. This is the recursion that the computers can do in their sleep. Now, let's see what the solution to this is. This is test. This might be useful for your discussion and homeworks coming up, but let me expose you right now. So sticking a equal to zero. So for i equal to zero x D of one as what is lambda d x d of zero plus b u d of zero, right? What about for I equal to one? X D of two equals lambda d x d of one plus b u d of one. Now, from the previous line, I know x D of one is given by that. So it's lambda d times lambda d x d of zero plus b zero plus b u d of one. So what does this become? This becomes lambda d squared x d of zero plus lambda B u d of zero plus lambda d lambda t plus B u d of one. So you see the pattern in mind. Let's do one more. Then you can see the pattern emerging. So x D of three is going to be, you can see here that are sticking lambda d times x d of zero. So that'll be lambda cubed times x d of zero plus Lambda squared times B times u d of zero plus lambda B times u d of one plus b u d of two. So what is the general pattern that you see here? You see that x d of k, you escape. There's going to be lambda D to the k times u d of zero. That is the initial state, UD of zero. So DX DT plus you have a summation of what you will have. Lambda to the k minus one minus I times B times u d of I from I equals 01 minus one. Which D or B? B. Yeah, BSD. Alright, I should have had BDS everywhere. You're right. Okay. B is the discrete-time be yeah. I'm not gonna go back and fix it. Okay. So you guys Sure. Yeah. Another question. Yes. They should all be lambda D is incorrect. Let's do at least a few. Let's actually fixed the lambdas. You know what? I'll fix everything. I don't want you guys to be confused. It's just annoying to write all this. I think I got out of it. Okay, Good, good, good, good catches. So in general, you will see that if you were to do it for the vector system instead of the scalar system, you will have x d of k vector. We did the scalar case. Lambda d will be replaced by a sub D to the k. This is a matrix to the kth power times x d of zero. That's still the same. Plus summation I equals zero to k minus one of e to the x d of zero has to have an arrow since everything is in the vector case, it'll be a to the k minus one minus I, B sub d times d to the, right. And this is the general solution. This is for k equal to 12 and so on. Okay? So it's exactly the same. Alright? So question. Ah, for the summation, this should be a vector. Otherwise it's fine. What plus your lambda d has been replaced by a sub D, right? Oh yeah, this should be. Thank you. I'm gonna, I'm gonna miss all these subscripts, but you guys are on top of it. I do it to keep you alert. That's what they say. Alright, so let's go back. Um, yeah, let me also generalize this to the vector differential equation case that might be useful, especially for your homeworks coming up. So let's go to the, okay, we have studied the scalar case. Right? Now, let's look at the vector case where your states are n dimensional and your control variables are m-dimensional. Remember, n and m are the dimensions of the state space and the control space, right? That's our assumption. Again, we start with, we start with our vector differential equation. And we recognize again the same argument due to the sample and hold of the zero order hold, you know that you see of t for the interval from i delta t I plus one Delta is going to be flat. But UD of I, of course it's not gonna be a vector because you have control variables, but they're all going to be flat individually, right? So the whole vector if piecewise flat. So that's why you d of i becomes constant. And then t is in this range for doing this. And then we, we are going to resort to stuff that you have done earlier. Professor nickname studied, taught you guys how to do diagonalization and change our basis. Same deal. These are vector differential equations, use the same techniques. Even whether you're doing control or anything. You know, vector differential equations are solved by splitting them into scalar differential equations and diagonalizing. Okay, so just a brief reminder. I don't want to spend too much time because we've already gone through this. But as a brief reminder, X sub C, which is our state variable, is encoder encode the standard basis. But we know that to do diagonalization, we have to convert to the eigenbasis, right? That's what makes life easy. Sorry, decouples all your vector equations into a bunch of scalar equation. Same deal. So y sub c is the eigenbasis. Again, as a reminder, what that means is that I'm going to multiply to convert z to y, I'm going to multiply by V inverse. Remember that what is v? The columns of V are exactly the eigenvectors of a are a sub-sequence C for continuous time. Sounding familiar. Yeah. Okay, good. So convert from, because I'm given a general vector differential equation where a sub t can be arbitrary. It can be, it need not be diagonal, right? Authority diagonal, you're done. Otherwise you have to make it diagonal. The way you make a diagonal lift to change the basis to the eigenbasis. And that's just the trickier. So xy is therefore v times y c. So my, my differential equation, my vector differential equation converting from xy to YC. So d y d t is going to be a sub c times x sub C inverse. So, which is, I just recognize that d V c d t is V inverse times DX DY DT, DT linearity. And then the right hand side is gonna be a sub c times XC of T, which is V inverse xy plus B inverse b c. So I'm just replacing, I'm just multiplying both sides by V inverse of this by V inverse. That's what I got here. And then I recognize, I'm going to, because this thing is very complicated and I don't want to keep carrying it around. I'm just going to abbreviate V inverse times bc times 2D array as some z of the z vector which depends on UD. And then from the starred equation, which one is the star? This guy? This is what we did here. Now I know that xy is V times with YC. So just do V inverse a, V plus V inverse b. So this distance, z, z of I, write my shorthand for all that stuff. So what do I have? A V inverse AC times V, where V is the eigenbasis vector. Matrix rather is diagonal. These are the eigenvalues of a sub c lambda one through lambda n. So what have we done? We have decoupled our vector differential equation into n scalar differential equations, that there's no coupling because it's diagonal. So you can write the kth row of this is just gonna be, this is the Kth entry of YC of t, which you call y sub c comma k. Just more notation, sorry. Lambda k times y sub c of t plus the k'th element of z of I. Okay? There's just a review of stuff you've done. I hope this wasn't too fast. Give me a thumbs up if you're okay. Okay, good. So this is true for k equals one through n. And this is the key is that the trick was, as you have studied, by going to the eigenbasis, you can decouple this vector differential equation. So if you have a very complicated system that you have to solve, no problem. First, do the eigenbasis decomposition, decouple everything. Do the control one at a time. The way that we described earlier, put it back together. Okay, so conceptually it's very straightforward. So, but it's a powerful way of thinking. Okay, Let's trim the scalar k. So any one of these differential equations, the scalar which are decoupled, are now going to be, we know what the lambda k and the z i k is like the proxy for U of K. It's a function of it, some complicated function which I didn't even write because we know, we know how to go back and forth. So this is the proxy for the U of k vector. You have a vector rather. So we know that we derived these expressions, right? So we derived this and this, assuming lambda k is not zero. If lambda k is zero, you replace the whole thing by delta. That's it. That's the caveat we talked about. So you stack these up, stack these n scalar equations up. We know that y d of I plus one for the first row is e to the lambda one delta times y d of I plus e to the lambda one delta minus on our lambda one, the first term times z array, and so on and so forth, right? But are we done? Well, our controller starts in the standard basis. For your convenience. You went into the eigenbasis domain. But please be decent enough to come back to my domain because my controllers on a regular basis. So you can't just give me the answer in the Eigen domain. So you have to go back. And to do that, you're gonna go from Lady back to XD. And that's, we know D will take you from xd2yd y d t. The inverse takes you from XD to id, so Vt x here from VDJ XD. And by the way, all this is assuming that this is diagonalizable. So we will study the case where things are not diagonalizable later in the course. We can deal with that. But for now we assume that the ACF, a sub C matrix is diagonalizable, meaning that the v vector, V matrix, the eigenbasis are all linearly independent. When you do that, you know, all these entries, all the Lambda i's are distinct and therefore you have full coverage. Okay? So you go back and then you go back by multiplying by V. So it will be V times this e to the lambda delta matrix vector B inverse XD. You guys have done this, I know, but multiplied by v times the same time z of y and z 0 vi I have substituted what I had earlier. Remember we had said that z of I is going to be B inverse B CUDA of that whole masters. Bring it back here. B inverse B, C UD of AI. And you're done. That's my final solution. Pretty neat, right? Starting out with, again, the key is to start do things in a simple manner and keep building up knowledge beautiful for your studied about vector differential equations. They come in handy here. Okay? Any questions? Okay? If not, let's continue. Okay, So we're going to change our gears a little bit. And let's talk about what we have done so far. So let's stick to the scalar case because it's easy to talk about. We had our differential equation, continuous time differential equation, which we converted into a difference equation by sampling every delta for the XD and doing a D to a piecewise constant interpolation at intervals of every delta from zero to delta, delta to delta and so on. And we derived that the resulting mapping to the discrete-time difference, difference equation was given by lambda dx d of k plus b d u d of k, where lambda d and BD. Well, what we just derived, right? And the early part of the lecture, this is what you've done so far. I even put in the condition for lambda zero and lambda non-zero. The soul we are complete. Now, these are what are known as model-based control. In other words, there's a physics that underlies the difference, the difference, the differential equation. And that physics tells you what these model parameters are, namely Lambda and B. These are given by physical laws, if you will. We will, we will study examples later in the course. But, but there is a growing interest in cases where either you don't know the model too well or the parameters are not well understood. So what should we do then? What age are we living in an age of machine learning? What is machine learning? Tell you to do? If you don't know something. Learn. How do I learn? You try stuff. So I'm going to stick in some inputs, get some outputs, and see if I know, I suppose I don't know lambda and b. In this case, the discrete time lambda d and BD. We know that lambda and b are known. We know perfectly the equation. We just derived them. Whatever lambda d and BD are not known. What should we do? Well, I have a recursion equation. I know that x d of zero, the initial state. So let's say if you know that I can try a UD of zero and find out what x d of one comes out. And then I can try a UD of one and see what x D of two comes out and form a pattern. And say, lambda d must be this. My best estimate of lambda d is this. My best estimate of BD is that, right? So that's the philosophy. But these are model-based controllers are saying the system parameters lambda B, lambda DBD, and more generally in the vector case, AC, BC AD BD are well-defined and well known, right? Based on the equations we have derived. The alternate approach, so-called data-centric approach, where the model parameters are not known. So how do you proceed? As we said, you try various inputs and see what happens. There's a fancy name for this is called system identification. It's just try and see what you can do. If you wanted to learn the parameters based on data and you generate the data and see what happens. Okay? So this is just to emphasize that in the system ID problem, we still have the difference equation. But this is also useful in the case where we know that no matter how well we do data, he's not gonna get the exact relation because this is the real-world data is never going to mimic your measured data, is not going to be exact. And in order to acknowledge that we are not perfect, to be humble, we throw in an extra term, which is the error term. So I know my model looks something like this. Man, I could be off or I could have noise. I could have all kinds of disturbances. So I'm going to capture all of that by an error term. So this is the enter or disturbance to the model mismatch. So as you know, the saying is that all models are wrong. No matter what model you think. All models or life. Some are useful. Okay, That's the same. So if it's useful for your application, then use it. So of course, these are models derived from physics or they're not all wrong because we know that Newton's laws hold and so on. But anytime computers get into the mix, there's gonna be quantization noise and might have hardware failures. All kinds of stuff can happen. And therefore, you have to have an error term. Also, you can have disturbances in the control system. The dynamics themselves have noise in them. We have assumed there's no noise and the dynamics, but that's not true. Model parameters need to be estimated. So the goal is to learn lambda d and BD from the data. So how should we do with that? Let's open the floor up. How should I learn lambda d and b, d. I know the nature of the, so I know that this is the equation that I want to solve, right? This one, this one. I know. This equation I want to solve. I don't know lambda DBD. I also don't know p of k, But I have no hope of knowing E of k If k is a lost cause. So all I can do is try and approximate things, assuming that E of k was small. Or we can do some sort of optimization to minimize the norm of e of k. Okay? So that's, that's the philosophy we will adopt. But what are some ideas on how we can forget e sub k For now? What are some ideas we can use to generate to try to estimate lambda d and BD. So first, how many unknowns are there? Two. So how many equations do you need minimally to? How do I get these equations? So I can do one equation. Let's say sticking k equal to zero, I say x D of one equals lambda dx d of zero plus bd UDF. Let's forget the E of k term. That one equation and two unknowns. And we solve. Know. How do I get another equation? Yeah. Read the next year, basically. Remember, what do you have under your control? Your weapon is this right? This hole. So all k. K equals zero, you get about an equation. What about k equals one? You get another equation. K equal to two. You get another equation. So you have a slew of equations. But through all these equations, lambda d and BD don't change. They are the same. So you have hope that by getting a slew of equations, but just getting more data, I can do an estimate of lambda d and BD. That clear, high-level. Any questions? Okay? So goal is to learn. So lambda d and BD are the vector of unknowns. So start the system at k equal to zero, x d of zero. Note that XD or observations from the viewpoint of the controller, right? Because it's the state. We have assumed that the state for observable. There are more complicated systems where the state is not observable, but That's beyond the scope of what we can do in this course. But even then you can estimate the state. But let's not worry about that for all the states are operations, right? So I stick in x d of one is lambda dx d of zero Btu per year zero. I get, then I move forward one extra time. X d of two is lambda dx dy or one plus bd duty of 11, then x D of three. And then you have all these zeros. So what have you studied? That will allow you to estimate lambda d and BD from the sequence of equations. I want to words Least Squares. Yeah, our old friend, least squares. Remember 16. You guys were doing least squares to the Garuda, right? Good. Here you're going to use it. So you want to use least squares. What does least-squares do? It allows you to solve this equations in a way that you can approximate it in a manner that you minimize the norm of the error term that you don't know about. Okay, so let's do a brief In the interests of time. I am going to I made a slide on least squares, but you should really go back to your 168 notes and review them. If you have, if you're a little rusty on least-squares, it is. It's it's good to remove the cobwebs and get get removed the rest. But let's give you that said, let me spend 2 min giving you a refresher on least squares. And the way I like to see it, and I like to think geometrically rather than algebraically. So geometry is always. Make pictures always make life easier whenever you can try to draw pictures. There, try to, at least for me it works. I think for most people it works. So what is the problem? So we're going to see that S is, so I'm going to change notations a little bit to be consistent with what we are going to be doing. I know you have Y equals AX is the typical least-squares setup, but we're going to change it to S equal to d p, doesn't matter what variables are. So this is S1 through S L. So you have L equations or n observations, d L by N vector. And what do we know about least squares is that L is greater than n. In fact, typically much greater than n because he wanted to combat the noise, the error term. So in this example, d is l by n, p is n by one, has this L by one, and the error vector is also n by one. Least-squares is about finding the best solution to this is the unknown. The p is the unknown. You are given S D and you don't know either, right? You only know P and S, sorry, D and S, From that you have the inverted and get p. And these quizzes, the solution is the one. You choose that P, such that S minus dp squared, which is the error term squared, or n squared, is minimized at the right value of p. The right value is the so-called least-squares value. And let's look at the geometry of the problem that will explain things. So this picture is worth 1,000 words are equations. So what am I drawing here? So this is the subspace of the column, the column, column space of D. So all the vectors that live on this subspace, ah, live in the column space of D. So they are all the peace for which d sub P lies on the subspace d. All vectors of the form d times p lie on this subspace. So it's a subspace of R LR Ellis and larger dimension. So S in general is gonna be an arbitrary vector in R L. There is no need for it to be on the subspace. So if I want to find the best approximation to S while remaining on the subspace, if that's what demand, right? Because dp equals x, that means I must live in the column space of D. What should I do? Or the picture say? Intuition's sake. I can move anywhere along this plane. I want to be as close to the Euclidean sense as possible to where should I go? Yeah. Yeah, You want the projection of S onto the column space to be your solution. That's exactly the PLS, this point right here. So at this point, you have done an orthogonal projection of S onto the column space. So that's a 90 degree angle. So the error vector e, the green vector, is at right angles with the P ls, PLS is the solution that we are after. That's the best solution in the least square sense. So again, you can go through the math, which I'm not going to do here. I'll go very quickly. We know that the error is minimized when e is orthogonal to the column space of D. So these are all the equations. That says if e, The error vector is orthogonal to the column space, it must be orthogonal to every column and all the linear combinations. So these are the equations that dictate e is orthogonal to the first column, the second column, and so on. Try to show that a transpose here. So d is given by D is given by these columns. D transpose, d, v1 transpose, v2 transpose. So you combine all these together, you get d transpose E equals zero. We know that the error, which is S minus dp is such that at the optimal solution, we know that d transpose times d. So d transpose times S minus d, p, least squares must be zero. That's our geometry is telling you that. Then you solve this equation, d transpose d PLS equals d transpose S. And you get the familiar least-squares equation that you guys should know by now. Which is that as long as d transpose d is invertible, my least square solution to P, the unknown is going to be d transpose d inverse times d transpose S, which have derived. So in case you have forgotten it, go review this, but go back to your 168 to get a better sense. I hope this is clear to you guys. You guys are on top of this. Okay. So how many time we have? About 10 min. So what should we do? Let's do, okay, let's do least squares for the scalar case. Yeah, I mean, it's a fairly straightforward application of least squares to our problem. So I can't seem to find help. I don't know if I need them. I just wanted to. Correct. Okay. So unknowns are lambda d command V d. This is still the scalar case. Goal. Has to learn lambda d and BD from data. So my equations are x D of one equals lambda d x d of zero plus B sub d UD zero plus zero x D of two equals lambda d x d of one plus b d u d of one plus e of one, and so on. So my solution by putting everything together. So how do I make this are in least squares. We know that we want a DP equals S, right? That's what we were just did. So what is my d vector and what is my P vector? P is the unknown vector. What are the unknowns? Lambda d, n, Pd. So let's take the unknowns here. So what should I multiply on the left-hand side for Lambda DBD to be the unknown and still have an equation of the form of DP. So this is going to be whatever we do. This is gonna be the D matrix. This is gonna be the P matrix, and this is gonna be the S matrix, right? Based on the notation we just used. So what should DB? Anyone? What's the first row of d? Look at the equations. X d of zero, u d of zero. What does the second liquid actually I should have. I didn't draw this to scale, so let me do that. Let's stretch this out. Sorry. Let's emphasize the fact that you have tons of data. Let's make it huge. Okay, From here you can see that x d of zero times q d of zero will give me what? X d of one. That's the first equation. Similarly, there's something for the second equation, which is x D of one, UD of one equals x D of two, and so on. Until, let's take x D of l minus one, UD of l minus one equals x D of hell. So in general, the larger the better our approximation because averaging out all the noise and estimating my unknowns better and better. But the flip side is, if more data, it's more processing, it's more delay and everything else, right? So this is my d, This is my P, and this is my S. So what is my P least-squares solution? We just derived it. It's d transpose d inverse times d transpose S. Well, I know d and I know S. This is my data. Because look at the entries of d. I have to start with some known X d of zero. And then all the UD, they're under our control and they induce all the xs d. So d is completely known. S is also completely known because they are just functions of that. And this is of course true if D transpose D invertible. Okay? So what happens in the vector case? So this is the scalar case right? Now. The general vector case of least-squares will do an example. Because doing an example is much more intuition building than even for the vector case. I want to see the simplest vector k first. And then it's easy enough to generalize to the larger. In general, if you're stuck with lots of a high-dimensional stuff, this is a tip boiled down to 2.1 and see what happens and build intuition from that. It's a good trick to also build to build your intuitions. So example, we'll do n equal to two and m equal to one. What does that mean? I have two dimensional state. Get rid of this annoying thing. I have something coming here that's not on the screen. On my screen I see annoying. Anyway, two-dimensional state vector, one dimensional control. The simplest extension from M equal to one. And if the state dimension m at the control dimension is to make the state dimension. Okay? So what does this mean? So we know that x of I plus one is equal to a times x of I. So I'm going to officially get rid of the subscript notation from now on, because we know we are in discrete time. We know how to convert from continuous time to discrete time. The handle with all the Cs and Ds, okay, we know it's all D's now. Okay, so if you're ever confused, put a D if, if it, if it makes you feel happy. So this is the equation, right? So in general, this is going to be what, what is the x sub I is gonna be a two by one vector. X sub one. X sub I is also two by one. This is also a two by one. U of I is just one by one scalar. What is B? Has to be two by one dimension matching. I'm just making sure that you understand the dimensionality involved. And this is gonna be two-by-two. So all the dimensions match. That's consistent with matrix vector multiplication, but very simple case. Okay? So let's continue with what one of my equations store. X1 plus. So I'm going to, this is vector, sorry. You doesn't have a vector because he was one-dimensional. X has a vector and e has a vector, okay? So x dx, this is x of I plus 11 is equal to a is a two-by-two matrix. So let's write it as A11, A12 here, 21a2, two times X1, x1, x2 of high plus B11, B12 times U of I plus the noise E1, E2. So that is my vector system, right? How many unknowns? I'm still doing system ID, meaning I need to identify my a and b. So now I need to identify this guy and this guy. So how many unknowns do I have? Six. How am I gonna get them? Go through it earlier? You had to do I equal to zero, i equal to one. To build up a whole stack of l, the l is large enough for your application. So let's just write this down and then we'll quit. This is a, this is B. So in general, because gonna be n by n, right? So that means n squared unknowns. B is going to be n by m, which is equal to n m, n times m unknowns. In our case, n equal to two, m equal to one. So total number of unknowns. 