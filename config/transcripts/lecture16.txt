Okay, time to get started. It looks like we have a very sparse class today. I wonder why could be the rain, could be the midterm, could be me. Who knows, right? Yeah, but I do want to see how to encourage more people to come to lecture. Any ideas for that. Extra credit for coming to class, okay. Yeah, probably we need to do gimmicks like that. Okay, so anyway, let's get started because we have stuff to do. So the topics for today are we going to continue with stability we started last time. We will do discrete time and continuous time version, but the concepts are the same. Then we'll get into feedback. Control is your first foray into actual controlling with feedback. And we'll talk about how to stabilize unstable systems by eigenvalue placement. Judicious eigenvalue placement announcements. As you know, your midterm is on Monday, eight to ten. Come early, don't come on Berkeley time can be for eight. Check head for logistics. If you have any questions. I think there was a review session yesterday. The people attend. How many how many people attended? Okay. Good. How was it? Was okay. Yeah, we'll we'll give feedback back to the TAs. One good news on this rainy days, there's no lecture next Tuesday, Okay? You don't have to come in on Tuesday. We'll give you a brick. Okay. Any questions, logistics or otherwise? Okay. If not, let's get I'm gonna do a quick recap of the stuff we did last time and then we'll move forward. Recap of stability and in particular BIBO stability. So here's the discrete time version. So here's my difference equation. X of t plus one is lambda x of t plus u of t plus E of t. And these terms are use of course you are controlling put engineers choice. E is Nature's Choice. Noise disturbance model mismatch. Bibo, stable as bounded input, bounded output. And it's exactly what the name implies, that if the input control into the system is going to be bounded, then the output coming out, which is the state sequence, the state trajectory, better be bounded as well. If that is the case, you are stable. If that is not the case, your unstable. And mathematically that stated as the system is BIBO stable if and only if, whenever the input is less than E in magnitude, that means it's bounded by e. And of course, the error and, and other terms are also bounded by e. So both u and v are bounded by e. For all t, then there exists a finite k, k less than infinity, such that my state sequence will never exceed k less than or equal to if you want. I mean, it doesn't matter which you put it. You can put less than or equal to. Any questions on BIBO stability. We did a few examples, and we first did one. We did the scalar case, of course, we will do the vector case today. X of t plus one is lambda, x of t plus u of t. And we assume that Lambda is greater than one in magnitude and u is bounded by e. What is the trick you want to find? Our intuition is that lambda greater than one, it's going to make the system unstable. Yeah, question. Oh, yeah. Well, we did a calculation. I'll go back I'll go through a calculation that we, that we did last time, where we calculate the exact value of k. So we can calculate k. But in general, to do Bible, I get into it. We'll see. So in this case, we guessed based on our gut feeling that if Lambda is greater than one, you can see that it's blowing up, right? Because x of t, and then it's greater than one. X of t prime is greater than x of t. X of t plus two is going to be greater than x of t plus one, blah, blah, blah. So we believe that this is gonna be unstable. To prove it formally, what do you need to do? You need to show that there exists some input sequence which is bounded, which blows up the system, right? So unstable if a counter example, meaning the proof only requires you to find a single input, that is going to be problematic. And that's exactly what we did for this case. So you could even have made u of t equal to zero for all t. But just to add some flavor, let's say that the first U is z, is e, which is our bound, and the rest are all zeros. Then if you go to the calculator, I'm, I'm gonna go through it again. We did it last time. You see that the absolute value of x of t is equal to lambda to the t minus one absolute value times absolute value of lambda x of zero plus e. This is obviously bounded, but this goes to infinity. S lambda is larger than one, and so this is BIBO unstable. So there's a particular u of t for which your system blows up. Any questions? Okay. Then we did the case that what's your name again? She asked about, can you find the k, right? So this is a case where lambda is less than one in magnitude are guesses such BIBO stable. But then the proof is not going to suffice if you give me a particular u of t for which I am stable, because the definition says it has to be stable for all u of t, which is bounded. Therefore, we may be very careful that the proof for the BIBO stability is a little more involved. It requires you to show it for all u of t. So we need to show in math form rather than in an example form. Okay? So what is the math form? Is x sub one. Again, we write the recursion x sub one is lambda x zero plus u of zero. X of t is lambda x one plus one. And then we went through the recursion. I'm not gonna go through this again. We did this last time. These are just copied from last Tuesday's nodes. And then we come up with, of course, the difference equation. The solution to the difference equation, which is x of t is lambda to the d x of zero. This is my initial state plus the summation lambda to the i u of t minus one minus I. By the way, this is exactly the analogue in the differential equations case which you guys have been used to a lot more. This place, the analog of the integrating factors, integral. You remember that. We have done that quite a bit. So in the discrete case, integrals becomes sums. And actually this is called the convolutional some for those who are interested or those who want to move on to 120. This is actually a convolutional some of lambda and lambda of i and u of t. But you don't need to know that. But anyway, by just writing the recursion by pattern matching, you will see that this is the solution to the difference equation given by, by this. Okay? So now we know we want to show that x of t is less than k, less than or equal to Kevin and might have. So we take the absolute value of both sides of the starred equation. And that's exactly what we did. Then we invoked the triangle inequality, which says that the absolute value of a plus b is less than or equal to absolute value of a plus the absolute value of b. And you get by repeated application of the triangle inequality, we came up with the fact that my x of t in magnitude, because no more than the expression shown in brackets. Highlighted text, which is x of zero plus e over one minus lambda. Of course, in doing that, we have to invoke the geometric series formula. So make sure you are aware and are adept with that. So this will exactly be, this is a geometric series for Lambda to the I. And we know lambda is less than one, so this is going to converge to 1/1 minus lambda. So we know we have found the k. So we have succeeded in finding a k that we know our system has to be smaller than our state, sequence cannot be larger than K. That answer your question. She's sleeping. That answer your question. Okay. Good. Okay. Good. So that's what we did last time. Now, let's look at, I'm going to draw a plot of what happens when lambda is less than one. This is just a visual depiction of what we have already looked at. This is lambda equal to two. Here it is blowing up. Lambda equals half. It's converging to zero after the T, or two to the, two to the l or half to the L as a function of l, will consider the Lambda equals one case in a minute. But you can see when lambda is one, you're just constant. Or Lambdas minus one, you alternate one minus 11 minus one. Lambda is two. Minus two. You are going to again blow up, but your envelope is going to look, the positive envelope is going to look like this. And the negative envelope is going to look like that, right? You're going to flip-flop between blowing up on the positive side and the negative side. And likewise, when lambda is minus half, you're going to alternate between converging from the positive end and a negative. And these are just visual depictions of stuff that we've already seen. Then there's also the case of complex lambda. So, so far we have restricted ourselves to real values of lambda, but lambda can be complex as well as you know. So what happens then? They'll go back to your complex numbers, a review. We've already done complex numbers. Professor nickname did that at quite some length. So here's the imaginary and real access for lambda. And theta is the angle that lambda max where the real axis. And we know that you can write it as magnitude of lambda e to the j theta. So when you take lambda to the l, So when we are interested in the sort of understanding the growth off the term lambda to the L with lambda is magnitude of lambda e to the j theta. What happens to e to the j theta L, because you've got to raise lambda to the n. So what happens to e to the j theta L as n gets large? Just the e to the j theta L, It just going to go round and round, right? That's, that's the phase. The magnitude is always one. That's, you start at zero, then e to the j theta two, theta three theta and blah-blah-blah, and keep going, going round and round. But that doesn't have any say in whether your signal is blowing up because it's just going round and round. What actually has to say if the magnitude, so if lambda is larger than one, magnitude is going to blow up. If lambda is less than one, it's gonna, it's gonna shrink. So the magnitude of lambda is the key criterion. We set absolute value of lambda and lambda was real. And that generalizes nicely to magnitude of lambda to be less than one. Is that clear? Okay, good. And here are some nice pictures of what happens. This is the real of lambda and imaginary of lambda on the x and y axis. We're plotting here. This is, if you take this, this is the lambda equal to one flat. And this is lambda equal to minus one, which means you're flip-flopping between one and minus one. And then this is the, what's called the unit circle. You guys know that this is Lambda, is greater than one in magnitude because it's, it has an angle of e to the j theta, where theta is this angle. And you can see here then that it's going, this is what's plotted here is the real of lambda because we can plot for brevity. Only the real part of lambda is plotted. But you can see here that if you're on the real axis and say they say lambda is 1.5 or something here. It blows up like just as we saw here. Just as we saw here. Lambda equals two. Likewise, when you're on the real axis and lambda is less than one, you're going to converge to zero. If you are off the real axis, then you're going to oscillate because you're going to have this e to the j theta L term. And the real part is cosine Theta error, right? The only plotting the cosine Theta L part. So here's your cosine of Theta L, but the envelope is still going to be blowing up. So this is the envelope. And likewise, on the imaginary axis, you're going to be again 10 minus one. And on the negative real axis, you're gonna be one minus one if it is on the minus one and if you're greater than one in magnitude, which means -1.5 or something. Again, you're going to blow up. But you're going to oscillate while you're blowing. Phase is important. So phase represents something. But right now we are dealing with stability. So we're only worried about whether the system is stable or unstable, but in general, phase has an absolute role to play. But for this lecture It's purposes. Phase is not important because it doesn't affect the growth rate. It just goes round and round. But visually you want to see the thing they're oscillating, right? When you're all. Because in general, lambda is going to be a complex value. The general setting. Okay, good. So that's all the review and a little more. So we have already considered the case of lambda greater than one magnitude. And we said that was unstable. We saw, we gave an example, then lambda is less than one. We proved, we didn't show an example. We proved that for all u of t less than E, we will, we are stable. What about lambda equals one? Who wants to guess? What happens at lambda equals 0? Yeah. Probably depends on the input, yes, exactly. So how does it depend on the input? Perfect. I don't need to do it anymore. He's already answered exactly what you need to do for the Lambda equals one case. So in fact, let's do exactly what he suggested. Yeah, I'm, I'm not. From now. We're going to write, okay. So case lambda equals one. So we can write x of t. So I'm only going to consider the real case here. The complex case can be similarly worked out, I guess so you want to keep things a little easier here. So x of t is Lambda to the t, x of zero plus lambda to the k, u of t minus one minus k. For k equals zero to t minus one. This is our starred equation, right? The same thing we saw earlier, right? This guy just plugging that back. Okay? So we know lambda is one. So this x of t, Let's take lambda equal to one. So x of t equals x of zero plus k equals zero to t minus one, u of t minus one minus k. So remember that in order to be BIBO stable, you need to be able to accommodate or handle every u of t, which is less than E in magnitude, right? So can you think of something that is compliant with that, that is no more than E and magnitude. That is going to what I would need to put in here, as we suspect for the system to blow up. So clearly if u is zero for all t, This isn't gonna be stable because X of zero is bounded and x of t is going to be constant. But if I make x of u of t minus one to be equal to E, for all t, which is strictly within bounds, I'm allowed to make it up to E. So I'll make it e. Then what happens to the sum? So thank choose. So what happens is that x of t is going to be x of zero plus e times t. What happens as t grows? Thing is growing out of bounds. So this explodes, right? So it's unstable. Actually. It is called, in the literature, oftentimes, it is called marginally unstable. Because even in the absence of, of, of the input, even if the input is zero, if you have the slightest amount of disturbance, that's going to make it unstable. So you're kind of on the brink of being unstable. Yeah. How did the sum e times t, u of t is equal to E for all t. Which means what? Which means that this term, this term is always e. So I can take E out of the summation. E times one for k equal to zero or t minus one is what? E times d. Any other questions? Okay? If not, then well actually I'll give you an exercise to do do lambda equal to minus one. So we found for lambda equal to one, we found a u of t for which the system was unstable, right? That's why it's marginally unstable. What about for lambda equals minus one? We just pocket through. How do you think it will be? So you can, if lambda is minus one, minus one to the k is going to oscillate between, depending on the even or odd value of k, it's going to go one minus one. And if u of t minus one is always e, then the ys are going to cancel out right here, our e minus e plus e minus e plus e minus e. So you're gonna be bounded. You're not going to blow up so that you will not work. What you will work. Exactly perfect. So you know that the, the troublesome, that what we feel is that this u, this u doesn't work because a flat view is going to make the up and down notion version of Lambda cancel everything out. So what do you need to do to prove that this is unstable? This to make you also alternate between one and minus one so that the one times one is one and minus one times minus one to plus one. So it will always be plus one. So think about that. Okay? So that's an exercise. Find. You won't do it here. I'll give you some exercise for you to do. Okay. So let's move on. Two vector systems. So we've only done exclusively scalar systems because that's the easy to build some intuition. It turns out, the vector system based on all the stuff that you guys already know. And what we know for scalar systems is gonna be very straightforward. I hope. I don't think it has anything surprising. So let's start with a simpler version where x of t plus one. You know, I like to have simple examples to start out with. Let's say that I have 200 half example. So suppose that is my, my dynamical system. So it's a two-by-two. So you have two states and you can be whatever. Two or one. It could be. It's also to what, what do people think about whether, remember, in a vector system, you have multiple states and stability has to apply to every one of those states, right? So who thinks that this is a stable system? How about unstable? Why do you say it's unstable? Exactly. So you see that the first state, x one of t plus one is two times x one of t, right? That's it. You're dead right there. I don't care whether x2 converges or not. X1 is already dead in the woods. So this is unstable. So clearly this is BIBO unstable. So the key criterion as far as correctly pointed out to be that all Eigenvalues magnitude has to be less than one. Because there's a diagonal system. You don't have to worry about couplings between states. We'll do that in a minute. But we know how to deal with that based on our prior experience. So here are completely decoupled system of scalar equations. And one of the scalar equations is blowing up air go, you're dead. Okay? Now let's look at the more general case. X of t plus one is going to be a x of t plus u of t. I don't need a b here because we're just talking about stability. But in general, you can put a B there if it pleases you, but we don't need it. So who wants to take a crack at how we would proceed? So a is some general matrix. And in general you'll also have a B u of t, but we don't need b. B is just clutter for us. We can call the BU of ts u prime of t, We call that U. So how do you think we should proceed? Because what have we learned so far? We know how to analyze scalar systems. We know that the Lambdas have to be less than one in magnitude. We also know how to analyze diagonal vector systems. We know that the diagonal entries have to be less than one in magnitude. Now we have the case of arbitrary any ole. How do you think we should proceed? Yeah. Louder. Yeah, fine. We know we have to diagonalize a, right? We know how to deal with diagonal is a is not diagonal. Let's diagonalize it. That's what we've been doing all along. So let's do it. So a is equal to V lambda, V inverse, where lambda. So the eigenvalues of a are lambda one, lambda two, lambda n and x of t plus one. So we can write a as V lambda V inverse. And of course, what is V? V is the matrix whose columns are exactly the eigenvectors of a, right? We studied that earlier. So these columns, I'm going to be the eigenvectors of a and Lambda. Diagonal elements are the eigenvalues of a. Everybody with me. Yeah, good. I don't want to lose you because that's an important concept that we have repeated several times. You saw it first in the context of circuits, and then again a few lectures ago. And then again, you see it's a recurring theme, which means it must be important. So pay attention to it. So v sigma v inverse, which is a times x of t plus E of t. Okay, so let's see how the system works. Let's multiply both sides by V inverse on the left. So we inverse times x of t plus one. The B inverse will cancel the V on the left, leaving us with what we did. I miss a UFD, Yeah. Okay. Sorry. I missed something here. U of t and e of t. So lambda times v inverse x of t plus v inverse u of t plus ne inverse e of t. I just multiplied the left-hand side by V in on the left by V inverse. Now we will do our familiar notation of, we'll call this x Tilda t plus one. We'll call this x tilde of t. We'll call this u tilde of t and e tilde of t. So what do we have? We have that x tilde of t plus one equals lambda omega lambda times x tilde of t plus u tilde of t plus a0 tilde of t. Now, this is diagonal. So how do I analyze the stability of this vector system of equations? Because that, yeah, and what do you need? What's the condition? All the eigenvalues have to be inside the unit circle. In the complex case, has to be less than one in magnitude. So that's exactly right. So find the eigenvalues. So that's gonna be my shorthand for eigenvalues, evils of a. If all have lambda less than one, then BIBO stable or not. Yeah. I didn't catch the first part. I mean, yeah. This is just to show stability. But yeah, if you took all the origin since, since I did the transformation, to go into eigenspace, you have to obviously go back to the original space to give you a solution. But we are only analyzing stability, stability wise. But then you transform it or not, if it's, if it's unstable in the transform them in transformed world, it will be unstable. In other words, tool. Because it's transformation doesn't blow up things because it just, it's just a weighted combination of objects. Okay, so that's all on discrete time. I want to quickly move to continuous time. So for continuous time systems, Let's go with scalar case first, we have the d, d t of x of t is equal to lambda x of t plus u of t. And the analog to the solution to the difference equation as the solution to the differential equation, which is what? You have x of t equals e to the lambda t x of zero plus integral from zero to t of e to the lambda t minus tau u of tau d tau. This is our familiar equation from doing integrating factors method that we studied way back, right. Everybody on top of this, right? This is exactly the solution you've seen many, many times. So what is our, again, that's for, you know, this is the homogeneous solution. And this is a particular solution based on u of tau. And the homogeneous solution is going to be giving us the key criteria. In that. Let's look at some examples of what we would do if d x d t equals minus two x of t. Okay, let's, let's, let's get some feel for what's going on. So when do you think things are going to be stable? So clearly, the factor to watch out for is e to the lambda t, right? So what is x of t? In this case, it's going to be e to the minus two t. Let's take u of t to be zero for now. That's the solution to this very simple differential equation. Dx dy, dy is minus two x of t, e to the minus two t. If you were to plot this, what do you get? This is x of zero, right? What happens to e to the minus two t? The case, right? So this is going to, so this has to, all the notions of stability in that my system is converging, is going to zero as t gets larger rather than blowing up. On the other hand, if you take dx d t to be two x of t, then x of t will be e to the two t x of zero. And your picture is going to look like that. This is x of t. This is x of zero. So it seems, suggests based on this, what does it seem like? The condition that lambda has to satisfy in order for you to be stable. So in the discrete-time case, we said all the magnitudes of lambda have to lay off all of your system. For the scalar case, the magnitude of lambda has to be less than one, right? In the complex case, it has to be inserted a unit circle, so that will always be less than one in magnitude. So what do you guess is to similar condition for lambda here? Yeah. Yeah, zero is the demarcation, right? Because, because the way in continuous time, the way it manifests itself is in the form of e to the lambda t term, right? The discrete-time to have just a Lambda, but now it is e to the Lambda. So e to the lambda when lambda is positive blows up lambda t, e to the lambda t when lambda is positive, is going to blow up. Because as t gets larger, e to the two t, e to the three t, e to the 0.1 t. Even, even if lambda is less than zero, less than one, but greater than zero, you are in trouble. Whereas when lambda is less than one, less than zero, then it will be e to the minus something t. And that's going to converge. So you're absolutely right. And we won't go through the details. The analysis is almost identical, so in continuous form and just write it down here. Continuous time. For general complex lambda case. What matters is when Lambda is real than Lambda is greater than zero, when lambda is complex, because it's e to the lambda t. Right? So maybe I should mention that here. Okay, let, let, let's quickly. If lambda is complex, then e to the lambda t, e to the real of lambda plus j imaginary of lambda times t, which is e to the real lambda t times e to the j imaginary of lambda t. That's what happens. Again. What happens to the e to the j imaginary of lambda t? E to the j terms just go round and round. So imaginary of lambda plays no role in the stability. He only thing that plays a role. The real part of lambda. Write the real part of lambda is the one that is responsible for the growth. Whereas e to the j imaginary lambda of t is the one responsible for the phase. How fast you go around the circle. Therefore, reel of lambda greater than zero. It's the criterion for unstable real of lambda less than zero. You can show a stable using an argument exactly like we did for discrete time. I leave it to you to do it. I don't have time. And it's not really going to add much more conceptually. It's exactly the same argument. Okay? So you have to show that for all u of t is going to be bounded. And you will exactly use the same method. I will leave it to you. And reel of lambda equal to zero. Because again, going to be marginally unstable, which for all intents and purposes is unstable. Okay. Who cares if it's marginally or not, right. Either stable or not. Kind of like pregnancy. You're pregnant or you're not, can be marginally pregnant. Okay. So let's take stock of what we have done. So recap. One, we have identified the system, right? Going back to a few lectures ago. This a system ID. And we have learned the model parameters. That's the first thing we did before we try to control a system. Let's learn the model parameters and let's see what the model is. And we know the use least squares for doing that, right? Second thing we did is that once we have the model, we asked if the system is stable or not. And that's exactly what we just finished. We know now what constitutes stability, and we don't want unstable systems. Third, what can we do? If our system is unstable? Can we make it stable? Because, and how do we make it stable? We have the control input, right? We can use that to potentially stabilize an unstable system. So that's, that's the hammer we have. We have that hammer. And four. So this is called feedback control. So this is the next topic we're going to study. For. Can we get our system to go? Where we want to go. So if it is a robot car and I want to move it from a to B, how do I make it move from a to B? How can I control it? And this is, comes under the general topic of controllability. So these two topics we're going to study next in the sequence of lectures. But just as a, as a, as an example. In circuits, you've already seen feedback. Where have you seen feedback in the context of circuits? Op amps, exactly. Op amps operate on negative feedback loops. And so we will study more about what constitutes feedback control for general control systems. Okay, let's go to discrete time. Okay? Let's motivate what we're trying to do by we'll call it stabilization. Fb is shorthand for feedback. Okay? So we have, I'm going to go back to the I plus one. So I'm going to vacillate between I and P and so on. So I hope it's not a confusion, It's just an index. So this is our open-loop dynamics. And we'll call this equation by star. And you guys know that this is the input, this is the disturbance or noise. So the question that we want to study now is, what if our system matrix a has an eigenvalue width lambda greater than one, we know that the system is going to be unstable in the open-loop sense. What do I mean by open loop? We'll see in a minute, It's where u and x are completely unconnected. So you give some u and then x happens and x, and you don't even talk to each other. That is open loop. And as you might guess, what's coming is we're going to close the loop. Okay? So the key idea to try to make things stable when things are not stable is to use the power of u in our favor. Okay, so that's the key. So can we achieve stability by designing? Remember, u is under our control. So by designing you appropriately. Now, in general, there are many forms that you can take, but clearly, you need to react to x, right? So the intuition is when x is blowing up, you have to whack it and make it go down. Hey, that's, that's the idea. But in general, that can be very complicated function. But since actually even advanced knowledge on this field is mostly restricted to the case where u is linear in x. So u is going to be some matrix times x or some scaled version of x. So we'll just restrict ourselves to the case where our input is gonna be a scaled version of the state and see whether that's good enough to do things. Okay, so that's the goal. So there are many choices. So let's try u equals some f times x. Depending on the dimensions of x, f will be the appropriate metrics. And what are the dimensions? We know u is m by one, right? So let's remember, let's remind ourselves. You is m cross one, x is n cross one. So what does f have to be? M cross n Exactly. So let's actually simplify life even more. As, you know, I liked the simple, simplest thing that makes the point. So let's make M equal to one, a single control input. Okay? Then of course, f is in one by N case, right? So in that case, what happens to u equals f x? Then x is gonna be x1x2 dot dot, dot x of n. So u is just a scalar. Let's make it that he was a scalar. No, no arrow on top. This is the case of m equal to one. So we know that f is gonna be F1, F2 dot-dot-dot fn. F is in R1 by n, right? One row and columns. It's a row vector and groups. And this is equal to u. So, so let's try this you. Okay, so let's see what happens. You of high, there's gonna be f times x of I, which is going to be F1. F1 plus F2, x2 of high plus Fn. It's a dot product between F and hex NFA. Actually these things should be x1. I should be careful here. I don't want to confuse you. This d should be X1, X2, X n of I. Circle it like this. Okay, Is that clear? All I did was I have the x of y. It's x. X is a vector. It has n states. Somehow I can, if I can control those states with only one degree of freedom, which is my control input. But let, let me try doing a weighted combination of those states and see where that goes. So that's a first trial. And this is box this up. I want to draw a picture that hopefully makes sense. So here is my system, which is my x of I plus one. If x of I plus B U of I will drop the disturbance term. And we know that my dynamical system takes inputs as you and produces outputs has x. We know that what we are now open loop. If you do nothing, if the use and the x's have completely independent of one another or they don't connect with each other, the system is going to be unstable. But I'm going to close the loop. How do I close the loop? Very simply take X of, I, feed it into the feedback box F, which is the matrix that multiplies x. So this produces f of xy. And we know that we want to make F x of I equal to u of i. So what happens to my dynamical system when I make u of y equal to f x fy in the starred equation. So wherever I see you of I, Let's replace it by f times x sub i. Then you have a x of I plus B f x sub i. So a plus B f times x sub I. That's my new system. So let's write that down. So substitute u of i equals f times x of I. In. My starred equation, which is this guy, right? So wherever I see you, I replace it by f times x. I have an AX plus B f x. So combining everything will get that x of I plus one is going to be equal to a plus b f times x of I plus E of I. And this is my new array. A closed loop. Cl is for closed loop. So I used to have my system matrix to be a. But by being, by using my input control system, my, my control input. By just taking it as a sort of a transformed version, scaled F times linear multiplication of x. I have succeeded in sort of changing the dynamics of my difference equation from a to a plus b fx. So the b, f, b is the system we've already given to you, right? A and B we did using system ID. We have no control over that, but we have control over F. So we can use f to manipulate a plus B, f. Kinda like magic. It's pretty cool. So let's see how we do this. So this is called the closed loop system. So question. Can we design f such that the eigenvalues of a closed loop, which is a plus b f, are inside the unit circle, often abbreviated as UC. We know that all the eigenvalues of my system matrix must fly inside the unit circle. And can I use f to make that happen? So that's the, ANY questions. The big picture is really important. What we're doing first is going to be details of how we manipulate. Okay, let's try some examples just to get the field. Example one scalar, my favorite x of I plus one is equal to two x of i plus u of i. And clearly the system is unstable without feedback because of this guy. Unstable without feedback. So let's make you of I. So scalar system. So it's a simple, Let's take U of I to be f times x over y. So basically everything is scalar here, so it's x or y. So f is just a single scaling factor. So f x of I is just a scalar. So that's what we're going to see. What happens. What is a closed-loop system? X of I plus one plus B f, which is a is two, b is one. So two plus f times x, f, two plus f. Because remember a plus b f, right? A is two, b is one, f is f. So two plus one F to F to present, okay? So x of I plus one is two plus f times x sub i. What do we need for stability? It's gotta be less than one in magnitude. Can I make it less than one? Sure. That's what F is four. Right? Okay, so for stability, we want to plus F to be less than one in magnitude. Two plus. So if we want an eigenvalue lambda zero, we know that two plus F should equal Lambda zero. So f equals lambda zero minus two. As simple as that. Where would you like your lambda 0.9? Yeah, that works. Then make f to be 0.9 minus two. If you would like your lambda zero to be at -0.5, That's also less than one in magnitude. Go ahead be my guest. Make F to be -0.5 minus two, or -2.5. So by just changing the value of F, like magic, you have suddenly stabilized and unstable system. It's the simplest example. Any questions? Okay? So that's the key. So, so in general, f will be in some range. Let's do a slightly more involved example. Actually, let's do it on the next page. Example, two, x of I plus 10123 times x of I plus 01 times U of I. Okay? So here's another example. My a matrix is here. So this is my a, this is my b. Okay? So again, this is a case that we have studied earlier, where m is one and n is two, right? And if the system dimension, that state dimension and M is the control dimension, so again, a single control input. So there should be only a U here, sorry, I don't need an arrow here. No arrow for you. Use just one. Dimension, one. Okay? What do I do? Well, let's form a closed loop. What was a close loop? It's a plus B, f, which is equal to 0132 plus b is 01, and f is F1, F2. Okay? So what is this? Well, this has just zero-zero F1, F2. So when you do all the calculations here, close loop is going to be 013 plus F1 plus F2. Right? Let's straightforward calculation that matrix addition. So let's work out the eigenvalues. We will go do an aside here. Let's work out the eigenvalues of a. You know that the characteristic equation is given by Delta of Lambda I minus a, right? For characteristic polynomial equals zero. You solve for this back to your linear algebra, eigenvalue, finding days. And you can work this out. Determinant of lambda minus one minus three, lambda minus two equal to zero. Solve for this. And you will get lambda times lambda minus two minus three equals zero. Lambda squared minus two lambda minus three equals zero. So lambda minus three times lambda plus one equals zero, which means that Lambda is three or minus one, so that the two eigenvalues are three and minus one. That stable. Hell now, the three kids you might not want also kills you. They're both bad. One of marginally better than the other one is really bad, right? So unstable. Can get this thing to. Okay, never mind. Now, what about the eigenvalues of a closed ACL? Close look. Again, you can go through the same calculations. You will find the determinant of a determinant of lambda minus one, minus three minus half one. Lambda minus two minus F2 equal to zero. And you solve, you will get lambda squared minus two plus F2 lambda. So, I'm sorry, it's gonna be a little tedious, but I wanted to show you one example where I'm not checking the math. Basically we know how to find eigenvalues of matrices determinant of lambda I minus the matrix entries. So when you work this out, so let's call this equation one. So if we want the eigenvalues of a closed loop at lambda one, lambda two. So suppose we want to hand pick. By the way, this is also called an eigenvalue placement. I should have, I should have mentioned that back when we did the scalar case itself, when we first met. The way we can manipulate the eigenvalues to lie inside whatever region that we want. That's called Eigenvalue placement. So you place the eigenvalue, it was somewhere, but you moved it all the way to the safe zone, alright, for its table. So that's called Eigenvalue placement. So the lambda one and lambda two. So you will get lambda minus lambda one times lambda minus lambda two equals lambda squared minus lambda one plus lambda two times lambda plus lambda one, lambda two equal to zero. This is how you will find the eigenvalues that you want. So basically what I'm saying is I want lambda1 and lambda2. So here's lambda one, lambda two, and here as lambda one plus lambda two. So if you call this equation two, by pattern matching 1.2, we have two sets of equations, right? What is the coefficient of lambda in equation one minus times two plus F2. So therefore, we want, sorry. So we want if you look at the lambda one, lambda two terms. So basically what I'm saying is that this, these two have to be the same. I want lambda1 and lambda2. What I have is two plus half minus two plus F2 must be equal to lambda1 plus lambda2. And we want a minus three minus F1 to be equal to lambda one, lambda two. And that means that F1 is equal to minus lambda one, lambda two, minus three. We also want, also, we want to have F2, which is this guy, the violet guy, to be equal to lambda one plus lambda two. And that tells me that F2 should be equal to lambda one, lambda two minus two. So I have two weapons. I can fire them any arbitrary I want. One is F1, the other left to right. These are my two control. The feedback system, F1 and F2 are within my control because I'm multiplying x by F1 and F2 to get you your, you. Yeah, I'll come to in a minute. So what this is saying is if you have lambda one and lambda two to be your desired eigenvalue placement in your closed loop system. Then if I design F1 and F2 has marked in equations 3.4, I can make it, I can, I can, I can make it work. So any lambda one, lambda two, you desire to your heart's content can be done by just manipulating the correct values of F1 and F2. It's pretty cool. Almost magical, almost unbelievable. So e.g. I. Can get you in a minute. E.g. if we want lambda one to be equal to a half and lambda two to be equal to minus one-quarter, because that's what our system wants. That stable. You can pick F1 to be minus three, minus 18 -3.1 eighth is just some number. And F2 to be minus one and three-quarters just gained scalar games. By picking those gains, I'm suddenly able to eigenvalue place. What were my original eigenvalues? They were three and minus one. What are the new ones? They're gonna be lambda1 and lambda2. Almost magical. We can place eigenvalues. That's a technical term. From minus three, from three comma minus 12, lambda one, lambda two, lambda one and lambda two can be anything your design that your design won't. Let me ask answer your question. Do I ordered the last part of your question? You do need both because if you had only F1, you can only control. If you look at this equation. If you had only F1, you'd have to, you'd have two equations and one unknown, a one equation and two unknowns. And I can't solve for the other, right? So you do need both in this case, in this example. And both just means that I'm going to go back to our picture. This is the big picture that you have in mind. Here's my open loop system. This is my open-loop system. All I did was a tight, tight a little not from the output to the input going through this F system gain, close feedback gain. And in the case when it was Scalar was the most, the most evident thing, but just everything is scalar. This is unstable with a single gain. Here. I was able to suddenly stabilize it. Likewise, in the vector case, we will also see a run or maybe it, let me, let me, before I paint too rosy a picture, let me, let, let me add a cautionary example. Yeah. Lambda one plus lambda two should be two plus F2. Yeah, because this is, this is lambda one plus lambda to write this as lambda one plus lambda two. And this is lambda one times lambda two minus of this as lambda one template. I have a trick. I mean, maybe if I had a sign error, but you get what I mean, right? Okay, fine. I making small errors are gonna be very natural as long as it's not concerning. So I want to finish some time on I want to add a question. Does this always work? Okay. Let's try an example, three, which is 1102 times x of I plus 10 times U of M equal to one, n equal to two example. So the eigenvalues of a are 1.2. They're just the diagonals because it's an upper diagonal system. The eigenvalues of a are just on the diagonals. Okay? So this is unstable. Close loop is a plus b f, which if you work it out, is gonna be one plus F1 plus F2 zero to what are the eigenvalues of a closed loop? R, one plus one minus F1. So the one plus f11 minus one plus f 1.2. What happened? The closed loop system has one eigenvalue at one plus f1 and another at two. You got screwed. The two is going to kill us. So just to show you, you can just sort of, for any matrix, if you do this trick, it may or may not work. It very much depends on the matrix a. So in the first case it worked, in this case it doesn't work. So we're going to study when does it work and when does it not work? So that's called controllability. 