Yeah. Exactly. Yeah. You made it. I see the attendance is pretty sparse. We have to incentivize you guys to come. Probably stay, stay tuned for an announcement about getting extra credit for coming to lecture. If you have at least a threshold of half or something. Because this is not even 10%. Okay, So we should get started. I guess we haven't met in a week since you had the midterm this week. So I was getting some feedback on the midterm. So how was it? Not good? Very hard. Okay, but he was equally hard for everyone. So that's the equalizing part. But more importantly, I mean, don't, don't feel despondent. If you didn't do well, there's always chances to make up and you have the final step coming, right. You'll also have a redo of the midterm rate. I believe that's going to happen. I think they'll give you the Midterm graded back in time for doing the LNS pass. No pass for those of you who want to do pass, no pass for next week. Okay. So it's time to be a little behind because we missed the lecture because I didn't want you guys to come the morning after the night of the midterm. So last time we had done stability. This is many times I go, I'm just giving a recap. Dom stability feedback control, which allows you to do eigenvalue placement using a linear policy. That is x is my state. And I'm going to hit it with a linear operator f or matrix. And that gives me my control policy. And using that, we showed how you can place your eigenvalue is wherever you liked and using feedback. And today we're going to wrap up our feedback control lecture and also talk about controllability. Another concept. Which is separate from stability. It's, it's, it's an important concept. Any questions? Okay. So also I wanted to alert you that the notes on stability and feedback control and controllability are out on the webpage. Okay, So if you are, if you need to fill in the blanks between the lectures, I cannot cover everything in lecture. And there'll be some things that cover in lecture that are not in the notes, but generally the notes provide you a good backdrop, background and in more details on the material. Okay. So that's just a heads-up. So very quick. So I'm going to try to spend very fast since it's been awhile, since we didn't always get back into the mood. Will summarize BIBO stability. Bind bounded input, bounded output, right? It means if input is bounded, the output has to be bounded. And we derived the condition for that in continuous time. It has to be that the real of the eigenvalues have AC, the system matrix have to be less than zero, as shown in the shaded region here. In discrete time, the eigenvalue magnitude has to be less than one, meaning it has to be inside the unit circle. All right, so that's a recap. And this has, this has to hold for all the eigenvalues of the system matrix, either ASC in continuous time or AD in discrete time. So, quick recap of feedback control. How do you, what do we want? How do we stabilize an unstable system using feedback? Feedback. So here's my system. X, y plus one is AX plus BU of I. As you know, you feed in your control input and you get out the states rights, the state sequence. And by feedback, we mean that if we introduce a block in the feedback loop, which takes in as input x and output u of i, meaning you of I equals f times x of I with F carefully designed. Then you can see that the equation, the open loop equation, will become the close loop equation where you just replace by BF, sorry, f b times f times x of I is just mu of y. So by just substituting in this equation star u equals f x, you get the closed loop equation. And the key is that you have now altered the system matrix a to a close loop. Acl. Acl is close loop. So it's a plus B f. Using this very, of course, you could have done many control policies. But this control policy is all we can analyze and, and, and do good things with. So HCl is a plus b f. This is the open-loop system metrics. This is the closed loop system matrix. This is the feedback part. And this is using the linear control policy u equals effects. Any questions on this? This is just setting the tone for what we're gonna be doing. Then we did several examples. The first example was we started with a scalar system with x of I plus one is two, x of i plus u of i. As you know, the two being larger than one makes the system unstable in open loop. How do we deal with it? Well, introduce feedback through U of I equals fx fy, everything is scalar, so all the capital F or little f's. And the close loop system becomes x over y plus one equals two plus F. This is a plus b. F for this special case is two, b is one, f is f and x 0 vi. So you notice that the eigenvalue has moved 2-2 plus F. And if you want to stabilize it, we want to make the eigenvalue inside the unit circle. So you can pick f so that two plus F is inside the unit circle. That's a das statement, right? Of course we can do that for any f, for any eigenvalue you like inside the unit circle. And that's exactly what we do. E.g. if you wanted that lambda naught, any lambda naught inside the unit circle, just make F equal to lambda naught minus two. And automatically, It's almost like magic. You're going to be stable and you'll have the properties that you want for your system. Okay? So example two, slightly more elaborate. Instead of a two-by-two system width, I'm still one control. So n equals two, m equals one. Remember m is the dimension of the controller. N is the dimension of the state, right? That's, that's a recalling. So x sub I plus one is a times X plus B U of I. And you can calculate the closed loop system by doing a plus B f, and you get it in this form. And you can, of course, look for stability. And if you notice, the stability is of course given by the roots of determinant of lambda I minus a, also called the characteristic polynomial. So we set that equal to zero and solve for the lambdas and you get three and minus 13. Minus one is also bad because you have to be less, strictly less than one in magnitude. So they are both problematic. What shall we do? Well, let's try the close loop solution. Which of course, with 01 and F1, F2, you get these, this is the new system matrix. So what is it? You can find the new determinant to be. You can find the determinant of this close loop matrix to be lambda squared minus two plus F2 lambda minus three plus F1. And you can always now place your eigenvalues based on what you want. So we know, suppose we would, we would like eigenvalues of the closed loop system to be at arbitrary lambda one, lambda two that you'd like, of course inside the unit circle, right? Because you want to be stable. So in pattern matching, the pattern matching, this equation, with this equation, you can see the two plus F2 must be lambda one plus lambda 2.3 plus F2 must be minus lambda one, lambda two. And that's exactly you can solve for F1 and F2 as a function of lambda one, lambda two, lambda one and lambda two way we desire to place the eigenvalues in our closed loop system. So they are given to you. So are you design them, what you have in mind? And F1 and F2 can be calculated based on simply these equations, 3.4, like magic, right? You want any lambda one, lambda two. Here's the F1 and F2 for which you can get that lambda one, lambda two. Very important concepts that clear. Okay, Good. So that's exactly what we're saying here. You can eigenvalue lambda one, lambda two by designing F1, F2 according to these equations which are coming by setting this to this, we can also solve the quadratic, but avoid doing quadratic as much as possible. You don't need to do it in this case. Okay? The question, does this trick always work? It worked in this case for this particular a, right? When a was a was 0132. What about other A's? And in particular, we had just started to look at this particular a 110 to n equal to two, m equal to one. And this is my a, this is my B. Let's see if this works. Then the eigenvalues of a are 1.2. Okay? So that's not going to work. It's unstable. What are the eigenvalues of the close loop system of a plus B f. Again, we do it asked before. And you notice that the eigenvalues are one plus F1 and to then work. Why didn't it work? Stare at equation given by the state. So here's an equation, right? If you look at this equation, can you yeah. Okay. Can you speak louder a little bit? Yeah, the zeros and the tooth. If you look at the second equation, right? What is standing at here? The second equation says, the second equation says x plus one of two, or X, x of x I plus one of the second, the second element of x sub I plus one is two times the second element of x sub I. And there's no control for it because you zero. So you're going to have a system where the second component of the state is going to be multiplied by two at every step. And that's going to blow up. So you cannot stabilize it. It's obvious you don't need to do any math. You would obtain at it and said, this is unstable and no amount of feedback, no matter what you do to F1 and F2. That's not going to alter the second equation, right? You can do nothing about it. So this is a case where the a matrix was bad luck for us. This cannot be stabilized using our method. So that's the key. So therefore, just 40 stated the eigenvalues of the closed loop system or one plus F1 and to still unstable and no choice of F1 and F2 are going to make them stable? Yeah, question. Louder? Yes. If b was 11, what would you have? Your your control could go on both, right? So you'd still have to analyze it. But in this particular case, we will go through the analysis. Yeah. Actually, if it was 11, you could make it stable. You're correct. But we want to know systematically, when can I say a system is controllable? This is the, this is exactly the controllable aspect. Okay? So that's what we're leading into. These are good questions. Okay, so what makes example to work? An example three fail. So let's look at it. And we are going to start writing now. You don't want to. So this is all about controllability. So let's start with our discrete time equation. State space equation. X sub I plus one is a X plus B U of I. And I'm going to assume that I have a single input control. So U of I is not a vector, it's a scalar. So it's only one component there. So I'm going to assume that single input, single control input. Okay? So now we have gone through solving this discrete system equations, true difference equations right here. You've done this many times, but let's do it one more time. So, you know that for I equal to zero, so the x of one is going to be a x of zero plus b u of zero. So I will have no arrows on top of you because it's a scalar, right? That's upsetting. For I equals one, you will have x of two is going to be a x of one plus b u of one, which is going to be a squared times x zero plus AB times u of zero plus b u of one, and so on. And for I equal to l minus one, the L minus one time, assuming it started at zero. You can see here that X of L. And we've seen this before. It's going to be e to the x of zero plus e to the l minus one. Be u of zero plus dot, dot, dot plus he be U of L minus two plus B U of L minus one. Just by recursing and seeing the pattern emerging for every error. So what is the general formula? That's, that's essentially the solution to this differential equation. I mean difference equation. So the solution is that Techstar of I is going to be and we'll take a we'll just take the first term over to the left-hand side. That will make it minus eight x sub zero. This is going to be equal to, let's write this in matrix or vector form. So it's gonna be a row vector here to the L minus one. Then I'm going to, I'm gonna, I'm gonna use this green line, two different to demarcate columns of the matrix. Okay? So this is, the first column is a L minus one times B, which is coming from this term. The second term is a l minus two times b, I should use. And so on. And then you'll have a baby. And we will write as a column, you are zero, u of one, U of L minus one. Let's pull this over to the left. And these are all the columns. So, so that is my equation star. That is a solution to my differential equation because that clear. Anybody lost everybody with me? Yeah. Oh, yeah, yeah. Okay. Sorry. You're right. That's my bed. Actually X of L. Good. Yeah. I couldn't hear you. Get b is a vector. B is, in this case, B is a column, right? Column vector because you have dimension one. So b has to be only one column. Remember, you have only one entry, U of I is just a scalar, right? So you have only m is equal to one in this case. So think of this matrix here on the left, separated by the green bars. Each of the, each entry is a column, B is a column. So if AB, so it says Create be all the way up to n minus one, bn and four. Okay? And this is a really important metrics which will allow us to identify the topic we are in, which is controllability. This is defined as C sub l, l for the time index. And what is c? C means it's the controllability matrix, it's sometimes called, okay? So this is okay. So going back to our notes, so the question is, let's use the red. Can we find sequence u of zero comma u of one, comma dot dot, dot. I'm U of L minus one. That brings x of zero from any state at time zero to a target. We call an x target at time. Okay? So what are we asking here? So our system is starting at some state at time zero. And we are asking, can I bring it to any desired state at time l, where the desired state of the next target. So I'm at zero, I want to go to x target. And I wanted to see if I can do it in steps. Right? That's that's exactly what I'm saying in words. And if you look at this equation, the starred equation, the green star equation, the answer is going to be yes. If what? I want you to participate now. So look at, stare at the green starred equation. And I'm allowed to pick my control inputs, U0, U1, U2, all the retrieval minus one. I want at time n. So x, x of l to be x targets something I desire, write an arbitrary design desired point. And zero is also arbitrary. So the left-hand side is something arbitrary because a is fixed, l is fixed. So the left-hand side is x target minus e to the l times x is x of zero. So they're all given, something given to you. So it's a known thing and it can be arbitrary. Can I control using my controls? You 01, all the way up three, well, minus one. Can I can I accomplish any left hand side? Yeah. Yes. Yeah, He said it. So note that this is an this matrix C sub L, right? Has to be such that if linearly independent this one, but it may, it may not be because l may be different from n. E.g. n maybe two and L maybe ten. So two by ten, you can have ten independent columns in R2, right? You can only have two by the time the third comes around. It's dependent on the other two. So you're almost there, but not a loader. Invertible, but this is not a square matrix. Need not be a square matrix. So only square matrices can be inverted. Exactly. So you look at the column span of the matrix, right? The span, meaning any weighted combination of the columns, right, must include the left-hand side, right? So x target minus a to the x z must lie in the column span of the CL matrix. Is that clear? Cannot live taught me because this is a key to moving forward. Okay, good. So let's write that down. Yes, If x target minus e to the l times x of zero lies in the column span of Cl. Remember C L is just the matrix a L minus one, b minus two. He B and B. And this actually is the start of the definition of controllability. Controllability is the ability to reach any target. State, picks target from any initial state, x of zero. And the formal definition of system controllability, controllable system. Let's write it down. So a system is called controllable definition. If given any target state x target and the initial condition x of zero, we can find an animal that is a timestep L and an input sequence, u of zero dot dot dot U of L minus one. Such that x at time l equals x target. Okay? So let's box this because this is a definition that you should remember. So let's make sure we understand the definition. Let's read it again. So what you're saying is, you are controllable if that exists, you don't, you can be controllable in any number of time-steps, okay? So L is not a constraint and it can be anything. So it may be that you are not controllable at the first step or the second step. But by the tenth step you are controllable. Okay? So if you can, if you can accomplish any x target given any x initial condition. And you can do it in steps where n is any integer, then you're called controllable. So definition clear. Okay. So, so in a word, so you can go anywhere in our n, Since the state if n-dimensional, you need to be able to go anywhere in the RN space, which has a dimension of n. N is the dimension of x. So that's the sort of informal definition of controllability. So question, how do we check this? How do we know? How do we show that I can go anywhere to anywhere in l steps? Well, if Cl or controllability matrix has n linearly independent columns for some l, then the column space, we know that our desired thing has to. Then the column space is what? What's the column space? If my controllability matrix has n independent columns, exactly, it's out in the end of the state dimension. So this means that we can make CL times u of zero, U of L minus one. Which is what? Which is the right-hand side here, right? It's the right-hand side, c l times this right hand side of star. So which is the right-hand side of the equation. Anything in RN by by choosing the input control sequence. Is that clear? Let's do an example. Things that are abstract here. So let's go back to our example that we did from the last lecture. Okay, so, so x of I plus one is equal to 0123 metrics we studied at the beginning of today's lecture and the end of last lecture. X of I plus 01 times times u of i. So again, this is a case where n is two and m is one. Just as a reminder. Okay? So this is our matrix a. This is our matrix B. And what do we have to check? What is the controllability matrix for this? It's always so the controllability matrix is given by this guy, right? You have to check the controllability matrix. The column span of that has to include RNA. That's the condition. That's how we check. So what is B? B is 01. So what does our Cl? So, so is it controllable in one step? What is our, what is the controllability matrix for l equal to one? First step. Go back here. What is the controllability matrix for l equal to one? Just be, so it's B, have ranked to be the vector. B is rank one. So it cannot be controlled in one step, right? And that's obvious because you have, I mean, you can see here, so B is 01 and c1 is equal to b. So again, the notation has C is the controllability matrix and the indexes for time. Hello, right? Okay. Let's look at AB. What is AB? You know, a and b. So we can multiply a and B. So it says the second column of hay, right? Because b01 and you multiply, it is gonna be 12. So this has dimension one. So in one step I cannot control it. What about in two steps? What a, C2, it's B, it's a, B and B. Write the two columns are a, B and B. So C2, There's 120112 independent from 01. Yes, not dependent, right? So what is the dimension of C2? If rank two? So the dimension is two. So the system is controllable by the second step. So therefore, controllable. Is that clear? Okay? Now, what is the intuition for why this is controllable? I mean, we, we went through the math, right? So let's, let's do more intuitive calculations. So we said controllability means I can go from any place to any place in that many steps. And this is an RN and n is two. So that means on my R2 plane, I should be able to move from any point on the R2 plane to any point on the autoplay. So what happens when, let's do an example? Let's say that we start out at the origin night zero-zero. And we desire to move to 10. Meaning, if you want to draw it on, if you wanted to do a visual thing, I'm going to start here. And I want to move to here. So this is the target. This is the initial condition. This is 012. Okay, So on my 2D grid, I just wanted to move on the x-axis to the right by one. So think of your car. You're at the origin at time zero. And then I want to move to the location 01. Can I control it? You're going to do it in the lab pretty soon. So well in one step. So can one be equal to 10? So if I start at 00 in one step, can I move to 10? No. Why not? Yeah, because my B is not very forgiving. Right? My B, it's not allowing me to make the first entry to be a one, B stuck at zero. So no matter what I make you, the first entry will always be a zero. There's no way in hell I'm gonna go to 10 after zero-zero in one step. But look what happens when you go to two steps. So what about x of two? Can Hex off to equal 10. Well, what spotting, what, what equation do we need to solve? To understand that? I mean, we went through the math and said, Oh yeah, it has full dimension because the two columns are independent, so it must be controllable. But can you tell me what input sequence will allow me to go 00-10 in two steps. So you want X of two to be equal to. We know that x of t is going to be. If you go back, let's go back to our controllability equation. Star t crit. And this is the key equation, right? So what does it say? X of two minus a 2x000. If I made it zero, I want calculations to be easy. So this term goes away because extra zeros, zeros. So I want x of two to be C2 times nu. That time for u vector, right? So I know that x of two to be C2, which is, we just calculated C2, I get 101021 times u of zero, u of one. And what does x have to x of two? It's x target, right? So let's replace x of 210. So I have to solve the equation. 10 equals 10 to one times zero. You have one. Can I find you a video of you of one such that this equation is true. What does it mean? When can you find it? It's another way of saying the same statement we did earlier. Yeah, when that matrix is invertible. In other words, it has rank two. Because since the two-by-two system, right? That's to have rank two. So as long as this is invertible. So now can you tell me what is the value of mu zero u1 for rich, I mean, you don't have to invert on the fly. But I believe one negative two should do it. Right? One, negative two. You can go 00-10. If you wanted to go to somewhere else, some other x, y, you'll have to find some appropriate u of 0.1 for which it will always be possible because you're your target. The right-hand side, the left-hand side of the starred equation, the green star equation is in the column space of Cl. That's the reason. So I'm just giving you intuition why the, why the math says it even physically this will be true. Okay, moving on. So let's do another example. Let's do our old example three, right? So what was that? So x of I plus one is equal to 1102 times x of i plus 10. So this is now a. This is B. Again, let's go through the mat. You'll see that c1 is equal to B, right? That's a. B matrix. Dimension is one. So obviously that is not controllable, then we need dimension to. What about c2? C2 is AB and B. What does AB? Anyone? 10, right? Because B is 10, hey, some matrix, so it's the first column of a by byte by matrix vector multiplication. So this is 10 and b is 10. What is the dimension of C2? What is the rank of F02? One. You don't have independent columns. The first column is identical to the second one. So this has dimension one. So it's a controllable in two steps. Now, let's try three squared b, AB and B. What does a squared B? Ab is one-zero. So a times AB, AB is 10110 to one. It's gonna be a squared b10. Again. What is the dimension of S3? Still one. You can keep trying to the cows come home. Didn't go C4, C5, see tendency million. What is the dimension gonna be? Hallway is going to be dimension one. So this is not controllable for any error. So this is an example of not controllable for any other dimension. So the basically, so another way of saying this. So let's again, let's give some intuition for this. What are we saying here? So b is 10 and u is a scalar, right? That means I can only have control in one of the two dimensions, right? So basically, imagine that you have your, a picture that so imagine that I have my robot car at the origin at time zero. And I want to move it to some location, say four comma five or something or three-three. At some time. Can I can I ever move my car from here to here? Well, if you look at the equations, you can see that this car can only move on the x-axis. Hit can move up or down. So that's what I mean by dimension is only one. You need two independent dimensions, two independent columns. So that I can think of basis vectors, right, that we have studied. So you can pull it in any combination of the basis vectors. That's what it takes to span any point in R2. But if you're stuck, only going left or right, you can't go up or down, then you can't control it, right? I can't make the car go anywhere I want on the plane can only go on a line. On the line that's the x-axis. Is that clear? Okay, So this is the intuition for why this doesn't work. It's not possible. So going back to our analysis, so you see that the dimension cannot increase. Further. Stuck at one, which is less than n, which is equal to two. So it's uncontrollable. Okay, So this is a consequence. So how do we observe? So what do we observe about getting stuck? So let's just getting stuck. Example is actually quite illuminating. So what we observe about getting stuck is due to the following lemma. It's a more general phenomenon. We just had an example where at some time I was at dimension one and then I increased by one. I'm still at the same dimension as I was before. And then what this lemma is saying is, you don't bother trying anymore. You're gonna be stuck there forever. Okay? So let's prove that. So let's show why that is the case. Everybody understand that statement. So we're going to show it here. So the lemma says that if e to the l times b, this is linearly dependent on the set E to the L minus one b here to the l minus two b, a, b, b. Then here to the l plus one B. Actually, I don't, I don't need these bars. Hormones will be fine for here. Then e to the l plus one, b is also linearly dependent on the same set, E to the L minus one b. Dot, dot, dot b comma b. So if I prove this lemma, then we don't need to keep checking for every particular element once dimension doesn't grow. Is that clear? Statement make sense? So what everybody is saying is, if a TB LB at time l, I am actually already linearly dependent on the previous columns. Then if I add another a plus one B, I'm not going to increase my dementia mr. Thing. It's going to be still be dependent on those. Okay, how do we prove this? So there'll be linear algebra and math and logic and stuff in this part of the course, okay, So you should get well-versed in this. So eight to the l times b. We know by definition, by hypothesis is linearly dependent on a to the L minus one and so on. So let's take some arbitrary weights. They call them alpha l minus one times here to the L minus one plus dot, dot, dot plus alpha one times AB plus Alpha zero times B, right? For some alpha n minus one dot, dot, dot alpha one alpha zero. By linear dependence. Since it's linearly independent, I can find some weighted combination of those guys, which is equal to me, right? That's what linear dependence means. Handoffs, weights happened to be the alphas, okay? Then e to the l plus one times b is equal to E times E to the B, which is a times, well, we know what E to the LV is, the alpha stuff. So let's write that down. So it's alpha to the L minus one, e to the l minus one plus dot, dot, dot plus alpha, one plus alpha, not be everybody with me. I'm just doing very simple algebra for now. Now. What do I do? Well, if you look at the LB and actually, let's continue. Before we do that, let's rearrange distance Alpha as a scalar. I can swap the order of the matrix and the scalar. So there's going to be how far to the L minus one. And a times a to the n minus one is just e to the l times b plus alpha to the l minus two times e to the l minus one, b plus dot, dot, dot plus for one squared b plus Alpha zero AB. I just multiplied it through. Now, what do I do? Well, I know the right-hand side, but I haven't entered the LB. But I know what a TLB is by hypothesis, it's dependent combination of the others, right? So let's go and plug in the right hand side of the LB in this equation onto here, the model E-jet. So you'll see here that this is going to be how far to the L minus one times alpha to the n minus one. Here to the L minus one. That's the first term. Plus all the others, plus Alpha one, he be plus Alpha zero b. Great Plains substitution. So what is this? What is the right-hand side? What's the last equation we did? What are the terms? You have? Yeah. Exactly. So linear is some other linear combination, not the Alphas, but in particular it will be alpha l minus one times alpha zero, alpha l minus one times alpha one, and so on. And alpha l minus one squared, a different linear combination of the same thing, which means this is also linearly dependent. So basically, this is nothing more than something times t to the l minus one plus something times e to the l minus two times b plus something times a, b plus something times b. Where the start are just some weights which I don't care to evaluate. So you're done. You're done. That's QED means I proved what I was supposed to prove. So I've shown that there's absolutely no point in keeping on going again and again and again, trying out different values of error. Once you start, once you're stuck, you're stuck forever. So that's what this lemma shows, a powerful lemma. We did an example to demonstrate that, but let's write down the page. So the lemma Implies if the dimension of the span of C l plus one is equal to the dimension of the span of C L, which is equal to d, let's call it d. Then dimension of the span of Cl plus two is equal to dimension of the span of L plus one, which is also equal to d. In other words, once the dimension stops growing, it stops growing forever. Okay, so let me go to so that's exactly, So let's look at this picture to give a visual depiction of what we're talking about. So on the x-axis, I have handled the time-step, which i'm, I'm, I'm examining things and on the y-axis I have the dimension of the span of Cl as I sweep, right? So you start off at one dimension of the span of c1 is one because c1 is b. B is a column vector, right? Remember, that was our example. So I'm a dimension one and then l equals two. Let's, let's say I keep growing, keep growing, keep growing. And then at some point I get stuck. I am a D and then I don't go beyond d. So how do I know if my system is controllable given that my state has dimension n, well, d is the dimension at which I get stuck. If d happens to be n, then I'm good. If d is smaller than n, I'm not good, right? Simple, simple fact, because we know that my span has to be an RN. My column space of my c vector has to be a span or n. And yeah, yeah, we'll get to that. He's asking, does that mean you only have to check at l equal to d? What is d? I don't know what D is, right? Yes. You're exactly right. So I'm just leading up to that. You guys are already one step ahead of me. So you could have e.g. you could write a program that keeps incrementing by L, right? One by one. And then see at what point it gets stuck and then say That's my dimension. What's a smarter way? That's exactly shown in this picture here, in the diagram here, don't worry about writing. Or we can just let me know the dimension goes one at a time, as long as we can add a single column by incrementing it. So when L is small and let's say n is 100, right? Your, your state has 100 dimensional and you start out at l equal to one. That means you have a single column of my matrix, then I make L equal to two. I have two columns. So my rank is hopefully going to increase by one. But if it gets stuck, I'm done. But do I need to check for all the else in the early stages 1-3 for now, just go straight to 100. Go to l equal to 100 because that's my state, right? And check what is the dimension for l equal to 100? Is it 100 or is it not? If it's 100, you're done. So instead of doing this incrementally, you can do it in one swoop. That's the point. Okay, so that's exactly what this picture is saying. So if n is equal to n, check whether the dimension of the span of CL is n. If it is indeed your controllable, but then you are less than N is some d less than n. That means you're not controllable because you must have stopped somewhere down the line, maybe at 23 or 35 or something, instead of going all the way to 100. And then once you get stuck, you get stuck forever because of the lemma. The clear. So we've done a bunch of things, but hopefully they kinda makes sense, right? If you have any questions, now's the time. Yeah. It's based on the dimension of the state vector, right? Because I need to remember what is the goal of controllability means my state vector should be, I should be able to control it and make it go anywhere I like. So if you think of the state, e.g. positions of your robot car. That's an example that we did in the example earlier. So let's say it's in two-dimensions. So I would like to go anywhere on this plane, on the, on the floor of this of this thing, right? I can start, I need to be able to start anywhere and control it and go anywhere I want. In two-dimensions, in n dimensions, it has to be in order n, right? If you have more than two. So anywhere in RN, I need to be able to go. Which means we said through the theorems that we studied the controllability theorems, that, that means that my column span of C L must be order n. So l clearly cannot be less than n, right? Because if L is 100 and if n is 100 and L is only ten, there's no way you're going to have a dementia. 100 from ten columns. Ten columns can utmost be ranked Penn. So, you know, it has to be at least 100. Any other questions? That's good. Yeah. Dimension of x star. What does x star? The target? You mean you want the lemma or which exactly which part I did. I'm not following your question. Controllability minutes. Okay. Yeah. Yeah, that's the most important thing. The most important equation for today is this guy. Yeah, in this example, we started out, but in general, b can be anything. But just for convenience, we may be a column vector, ok? Beat need not be a column vector. B could be to buy whatever, okay? Also. But semi general case is no different. So basically the dimension should, if you have e.g. okay, Let's when, when b is a column, right, then as n grows, you're adding a column to the left. You're starting out at B, then you are adding AB than eighth grade be hit with L minus e to the l b and so on. So as l progresses, your matrix is adding an extra column to the left. So the dimension is not going to decrease, right? Largest at most it's gonna be stuck or it might grow because they add an extra column. You have hoped that it fans and I've extra dimension. Now, if B is, let's say, of dimension two by n, rather n by two, right? So instead of b, so let's, so if let's say 1001, I should actually, let's make enlarge. So suppose will populate it any which way. So originally we had B2B, a column vector. Now let's say B has two columns. Well, let's go back here. What does it mean? So that means that I start out with the two columns. Then I'm going to add two more columns. Then I'm going to add two more columns. So I'm going to grow by two because B is of size n by two, right? Now, the condition still remains the same. You need to be able to span R n. So that means now we will have twice the number of columns. But the constraint is still the same, that, that dimension of that span should still be RN. Because my state is always n, right? So I only need to be able to manipulate. The state dimension size. So even if I grow by two or three, what does it mean to grow by two or three means is that I'm adding higher dimensionality on my input control. My input was only one-dimensional, so B was a column. If B is 2-dimensional, that means I have U of U zero of i and u one of i for every i. So I have more control. So clearly the more control you can do better. So if I grow by two, I'm gonna get to my task even earlier than b equal to one. So that's intuition. Okay? Yeah. Yes, yes, yes, No way I used to call them to be one day. That was just a convenience. The Lamar still applies once you're stuck. You're stuck? Yeah. Yeah. Exactly. Had at every time you do an a to the n minus one b, you'd have three columns at a time. Well, that's the way that things aren't, right? But lemma says that three b as length. If B has three by n by three, then e to the I times V will be n by three also. Because, because of the rules of matrix multiplication, it has two. Yeah, I mean, it won't increase more than n, right? So how do I know clearly an n-dimensional vector, I can't have more than n independent columns, right? Even if l was 1 billion and n are 100, 100, I'm gonna get stuck. Because you have to, because the dimensionality of 100,000 metrics is still 100. Rank is 100, right? So, yeah, you will grow by three. But every time you grow, you will be stuck. If n, we'll say 55, and n was three, then at 54, you're not yet still, you still have to grow 54 to 57. You'll see that the dimension will become 55. Okay? That's right. That's what I mean. So generally, is it clear? I mean, you do have to read the note and so on, but okay, so in the remaining time, I want to expose you to a concept which is called I just want you to be aware of this term. It's also in the note on controllability. It's something called controller canonical form. So it's a classic formulation in control theory. And we will do it for m equal to one because it's easier to follow. And in fact, CCF is actually, I believe, only defined for m equal to one. So let's look at this. So we, in general, we have been looking at state-space equations. X sub I plus one is AX plus BU of I, right? I mean, it's of that form. Now it turns out we saw that for some a's it is controllable. For some a's it is not controllable. We saw example two, but good. Example three, no good. So CCF are canonical controllable form. If a general structural form of special case of a and B for which you can always control by almost by definition. Okay, so let's go look at that. So what is the, if a has a certain structure and B has a certain structure, then you are guaranteed to be able to control that system. Okay. What is that conform? Well, that's the form where he has this form where if you look at so you have an i n minus one identity matrix. So you have all 1s, all 1s on this matrix column, and zeros everywhere else. On the last row, you have A1, A2 through AN, some arbitrary numbers. And the first row is all, all, the rest are zeros. It's a very special form. This is called the controllable canonical form, CCF, CCF for short. And B has the form of all zeros except the last element is one. Which means that if you're applying a control, only the last equation has any direct influence. All the others are zeroed out. You don't even control, doesn't even show up in these other state equations of state equations. Okay? So if you recall, our example two was of this form. Because example two was 0123 in the manner written here. Indeed, for this is, you can think of this as the E N. Is equal to that. So there's an n by n matrix. A2 for n equal to two was indeed of this form, right? So indeed, you have arbitrary numbers here. You have an identity in this column, this part, and zero here. So this is exactly of this form. So we will show that this is just a special case of a more general for larger n. Now, here's the key. If you look at the characteristic polynomial of a matrix, the n by n matrix, you can fairly show, in fact, you should show it as an exercise. If not, you can do it. You can do it in office hours or come talk to me. But this should be fairly straightforward to show that the characteristic equation that is the eigenvalues of the matrix, how the roots of this polynomial and this polynomial, it has a beautiful form. If you look at the last row, you can pretty much write out the characteristic polynomial from the last row. So you have, obviously it's, it has n eigenvalues since it's an n by n matrix. So we have lambda to the n minus n lambda n minus one minus a n minus one and lambda n minus two minus e to lambda minus A1. So you just write out the polynomial and reverse order of the a's. And that is exactly the characteristic polynomial for the special matrix. It's a good exercise to show that the characteristic polynomial is this. So come talk to me if you are stuck with that, but you should try to do it on your own. This is your linear algebra exercise. You guys need to be good in linear algebra for this course, right? If you add some in 16 and you'd have a lot more here. Okay, So now this is the example of our, our system A2. Remember this system has characteristic polynomial given by lambda squared minus two, lambda minus three. Indeed, if you look at it and it's lambda squared minus two, lambda minus three, It's exactly of that form, but that holds no matter what n is, not just two. That's the point. Okay? What happens for n equal to three? You have a cube, lambda cube minus three, lambda squared minus lambda minus A1 is the characteristic polynomial of this guy. So again, you can check that on your own. Check that the characteristic polynomial of a matrix, which is of this form, zero, all APIs in here, identity in the middle. And the inner part is indeed lambda cubed minus three lambda squared minus lambda minus favor this. All this generalizes. Now here's the cool part. To form the closed loop system matrix, we need to do a plus b f, right? That's what we started with at the beginning of the lecture. So a plus B, but B has a very special form. It has only 11 in its entry. So what is it going to be? So if you multiply b times f, it's going to be all zeros except the last column is going to be f1 through fn. Because that's a form of be, special form of B is a special form of a special form of B. And that will give you this E plus B F. What do you notice about the form of a plus B, f. Structurally compared to the form of a? Yes. No, it is exactly of the same TCF form, meaning only thing that has changed if instead of having A1 through AN, you know how A1 plus F1 plus F2, AN plus fn, f Scott added to the terms of each of the AIS. Okay, so that's what we say here. He came became a k plus f k for all the case when you do this. But we know because the form is the same, the characteristic polynomial is also gonna be the same form. So it's gonna be determinant of lambda I minus acl is gonna be exactly the same format as before, except all the AKS become a k plus F keys, all the terms, right? So that's the new part of what's, what's happened. Now, suppose I want my closed loop system. Remember what we did when we did example two or in general, all these examples, I want to place these eigenvalues where I want, right? I'm the designer. I would like lambda one here please. Lambda two, lambda three year. My choice. All the Lambdas are my under my control. So I would like this, these Eigenvalues placement for my n by n system, right? So you can multiply this out into a polynomial just algebra. The first term is going to be lambda to the n monomial. Second term will be sum of the Lambda i's times lambda to the n minus one plus dot-dot-dot. And the last term is gonna be minus one depending on whether n is even or odd. It's going to be either plus or minus, and then it'll be the product all the lambdas, just not just algebra. Now, I know that the polynomial, the characteristic polynomial of my closed loop system, She's given by this guy, right? Precisely how we got when I just add f k 2k. Now let's do pattern matching exactly like we did earlier. What will we get? Well, the blue must match the blue because that's the constant term. The yellow must match the yellow because that's the lambda to the n minus one term and so on. So you will have a set of equations here, one plus F1. The last term must be the same as minus one to the n lambda one to lambda n and dot, dot, dot. And the first term a n plus f n must be the same as lambda one plus lambda n. So that'll give me a set of equations. So F1, by just solving, taking a one to the other side, F1 is given by minus one to the n minus one. This minus a1.dot.fn is lambda one, lambda n minus k. So remember, the lambdas are my design choice. So I know what they are because I know what I desire them to be. So I can make these right-hand sides all known. All have to do is design the f's according to the equation. And you're done just like we did in example two. But it's holds in general. Okay? Now, the last part says that this is a fact. Then we're going to state, which is that any controllable system. If your system is controllable, I can always make it into CCF form by using a transformation. Just like you studied, how you can transform your standard basis to an eigenbasis which are diagonalized the system matrix. Just like that, you can multiply by an appropriately chosen t such that in the transformed world, you will look like CCF. And so you can do your design day and then come back. Okay, so that's the power of CCF. We're not going to elaborate on that in this course because you don't need to use CCF. But it's very convenient because we have a structure for which controllability is trivial. I've designed the F according to the equations. And then you can go back and forth, okay? Alright, I think we're out of time, so have a great weekend and see you next week. 